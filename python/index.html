<!doctype html>
<html>
  <head>
    <link rel="stylesheet" href="../style.css" />
    <title>Introduction à Python</title>
    <meta charset="utf-8" />
  </head>

  <body>
    <header>
      <h1>
        Séquence 3.4 - Bases Python avec un focus sur les aspects sécurité, outils de vulnérabilité
      </h1>

      <table>
        <tbody>
          <tr>
            <th>I-manuel</th>
            <td>B3M1 — Développer des applications numériques</td>
          </tr>
        </tbody>
      </table>

      <table>
        <thead>
          <tr>
            <th>Activité</th>
            <th>Compétence</th>
            <th>Évaluation</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              Activité 3.1 : Définir les spécifications techniques et
              fonctionnelles de l’application numérique.
            </td>
            <td>
              Utiliser les ressources à sa disposition ou faire appel si besoin
              à un expert externe pour contrôler l’identification et la teneur
              du résultat attendu ou approfondir un point technique.
            </td>
            <td>
              <ul>
                <li>
                  Les solutions trouvées ont permis de lever les doutes et les
                  inconnus.
                </li>
                <li>
                  L’objectif final et les moyens d’y parvenir doivent être
                  clairement identifiés.
                </li>
              </ul>
            </td>
          </tr>
          <tr>
            <td>
              Activité 3.2 : Développer à partir des spécifications
              fonctionnelles des algorithmes.
            </td>
            <td>
              Décomposer un problème complexe en sous- problèmes en faisant des
              analogies et des différenciations tout en changeant d’approche,
              de point de vue, face à un obstacle en vue de résoudre un
              problème algorithmique.
            </td>
            <td>
              <ul>
                <li>
                  Les résultats intermédiaires et leur mode d’obtention sont
                  définis.
                </li>
                <li>
                  La totalité des spécifications fonctionnelles ont été
                  transcrits en algorithmes afin de rédiger le code source.
                </li>
              </ul>
            </td>
          </tr>
          <tr>
            <td>
              Activité 3.3 : Transcription des algorithmes en code source.
            </td>
            <td>
              Traduire une solution algorithmique dans un langage de codage
              informatique avec l’utilitaire approprié.
            </td>
            <td>
              <ul>
                <li>
                  La totalité des algorithmes ont été transcrits en code source
                  afin d’effectuer les tests techniques.
                </li>
              </ul>
            </td>
          </tr>
          <tr>
            <td>
              Activité 3.4 : Modification d’un code existant et de son
              algorithme.
            </td>
            <td>
              Modifier un algorithme sans générer de dysfonctionnements en
              comprenant et s’adaptant si besoin au mode de pensée de son
              auteur.
            </td>
            <td>
              <ul>
                <li>
                  Le code source modifié est prêt pour les tests techniques, le
                  compilateur ou son équivalent ne détecte plus aucune erreur.
                </li>
              </ul>
            </td>
          </tr>
          <tr>
            <td>
              Activité 3.5 : Compilation, déverminage du code source.
            </td>
            <td>
              Remédier aux erreurs de codage ou de logique en comprenant ou
              interprétant les messages d’erreur du compilateur ou du système
              d’exploitation pour mettre au point un élément logiciel
              opérationnel.
            </td>
            <td>
              <ul>
                <li>
                  Les tests techniques prouvent que le logiciel produit le
                  résultat fonctionnel attendu.
                </li>
                <li>
                  Les tests techniques prouvent que la modification n’entraîne
                  pas de régression fonctionnelle.
                </li>
              </ul>
            </td>
          </tr>
        </tbody>
      </table>
    </header>

    <aside id="sommaire">
      <h2>Sommaire de la séquence</h2>
      <ul>
        <li><a href="#video">Pitch de l’auteur</a></li>
        <li><a href="#quiz">Quiz</a></li>
        <li>
          <a href="#decouverte">Découverte (14h)</a>
          <ul>
            <li><a href="#premieres-commandes">Premières commandes</a></li>
            <li><a href="#types-de-base-conditions-et-boucles">Types de base, conditions et boucles</a></li>
            <li><a href="#fonctions-et-classes">Fonctions et classes</a></li>
            <li><a href="#bibliotheque-standard-et-modules-externes">Bibliothèque standard et modules externes</a></li>
            <li><a href="#programmation-web">Programmation web</a></li>
          </ul>
        </li>
        <li>
          <a href="#fiches-ressources">Fiches ressources</a>
          <ul>
            <li><a href="#installation-et-utilisateur-de-l-interpreteur">Installation et utilisation de l’interpréteur Python</a></li>
            <li><a href="#choix-et-configuration-d-un-editeur">Choix et configuration d’un éditeur</a></li>
            <li><a href="#syntaxe-types-et-instructions">Syntaxe, types et instructions</a></li>
            <li><a href="#fonctions">Fonctions</a></li>
            <li><a href="#programmation-objet">Programmation objet</a></li>
            <li><a href="#modules-et-imports">Modules et imports</a></li>
            <li><a href="#bibliotheque-standard">Bibliothèque standard</a></li>
            <li><a href="#environnements-virtuels">Environnements virtuels</a></li>
            <li><a href="#flask">Flask</a></li>
          </ul>
        </li>
        <li>
          <a href="#atelier">Atelier (14h)</a>
        </li>
      </ul>
    </aside>

    <main>

      <section id="video">
        <h2>Pitch de l’auteur</h2>
        <p>
          Python est l’un des langages de programmation les plus populaires
          actuellement. Sa simplicité d’utilisation lui permet d’être
          intensivement utilisé dans de nombreux domaines hors du développement
          informatique, des petits scripts d’administration système aux plus
          grandes applications de calcul scientifique, en passant par
          l’intelligence artificielle ou l’embarqué.
        </p>
        <p>
          Cette simplicité n’est pas contradictoire avec une utilisation plus
          intensive dans le domaine du développement : Python est très
          largement utilisé pour développer de nombreuses bibliothèques
          variées, et surtout pour créer des applications Web : Instagram,
          ChatGPT, Spotify ou Dropbox utilisent par exemple intensivement
          Python.
        </p>
        <p>
          Alors, qu’est-ce qui fait de Python un langage à la fois simple à
          prendre en main et puissant ?
        </p>
        <p>
          Cette introduction à Python vous présentera les différents types de
          base, les structures algorithmiques et les fonctions, avec à chaque
          fois des exemples de cas d’usage. Nous verrons également comment
          importer des modules depuis la bibliothèque standard, mais aussi
          depuis PyPI, le dépôt tiers officiel. Nous découvrirons ensuite la
          programmation objet avec la définition de classes personnalisées,
          avant de terminer avec l’un des sujets les plus courants du
          développement Python : la création d’une application web.
        </p>
        <p>
          Tout au long des activités de découverte proposées dans ce module, nous en
          profiterons pour aborder divers aspects autour de la cybersécurité.
          Quels avantages et inconvénients propose Python par rapport à
          d’autres langages en terme de sécurité ? Comment prévenir certaines
          attaques les plus fréquentes avec les <em>frameworks</em> web ?
          Comment construire une gestion des droits efficace ? Nous verrons
          autour de cas pratiques comment acquérir de bon réflexes de sécurité
          lors du développement d’applications.
        </p>
        <p>
          Calcul scientifique, web, IA, devOps, automatisation… Quel que soit
          le type d’utilisation qui vous intéresse, faites de Python un atout
          dans vos possibilités de développement !
        </p>
      </section>

      <section id="quiz">
        <h2>Quiz</h2>
        <ul>
          <li>
            <p>
              Quel mot-clé est utilisé pour définir une fonction ?
            </p>
            <ul>
              <li class="correct"><code>def</code></li>
              <li><code>func</code></li>
              <li><code>fun</code></li>
              <li><code>let</code></li>
              <li>je ne sais pas</li>
            </ul>
          </li>
          <li>
            <p>
              Que contient la variable <code>_</code> dans l’interpréteur
              interactif ?
            </p>
            <ul>
              <li>la valeur du premier argument</li>
              <li>le nombre de commandes effectuées</li>
              <li>le numéro de version de l’interpréteur</li>
              <li class="correct">la valeur retournée par la dernière commande</li>
              <li>je ne sais pas</li>
            </ul>
          </li>
          <li>
            <p>
              Qu’affiche le script suivant lorsqu’il est exécuté ?
              <pre><code><span class="vert">for</span> i <span class="vert">in</span> range(3):
    print(i)
<span class="vert">else</span>:
    print("partez")</code></pre>
            </p>
            <ul>
              <li><code>1</code>, <code>2</code>, <code>3</code>, <code>partez</code></li>
              <li class="correct"><code>0</code>, <code>1</code>, <code>2</code>, <code>partez</code></li>
              <li><code>0</code>, <code>1</code>, <code>2</code>, <code>3</code></li>
              <li><code>1</code>, <code>2</code>, <code>3</code></li>
              <li>je ne sais pas</li>
            </ul>
          </li>
          <li>
            <p>
              Quelle est la principale différence entre une <code>list</code> et un <code>tuple</code> ?
            </p>
            <ul>
              <li>le <code>tuple</code> est ordonné</li>
              <li class="correct">la <code>list</code> est modifiable</li>
              <li>le <code>tuple</code> peut contenir des types différents</li>
              <li>la <code>list</code> est indexable</li>
              <li>je ne sais pas</li>
            </ul>
          </li>
          <li>
            <p>
              Qu’affiche <code>print((1, 2, 3)[3])</code> ?
            </p>
            <ul>
              <li><code>3</code></li>
              <li><code>(3)</code></li>
              <li><code>[3]</code></li>
              <li class="correct">une erreur</li>
              <li>je ne sais pas</li>
            </ul>
          </li>
          <li>
            <p>
              Que fait le code <code>from random import randint</code> ?
            </p>
            <ul>
              <li class="correct">il importe la fonction <code>randint</code> depuis le module <code>random</code></li>
              <li>il déclare la variable <code>random</code> depuis l’import <code>randint</code></li>
              <li>il importe un nombre aléatoire depuis le paquet <code>random</code></li>
              <li>une erreur</li>
              <li>je ne sais pas</li>
            </ul>
          </li>
          <li>
            <p>
              À quoi sert un environnement virtuel Python ?
            </p>
            <ul>
              <li class="correct">à éviter l’installation de paquets au niveau du système</li>
              <li>à émuler un système d’exploitation</li>
              <li>à lancer le compilateur dans un espace virtualisé</li>
              <li>à rendre plus rapide l’exécution de code</li>
              <li>je ne sais pas</li>
            </ul>
          </li>
          <li>
            <p>
              Quel type d’objet permet de stocker des couples clé/valeur ?
            </p>
            <ul>
              <li><code>array</code></li>
              <li><code>map</code></li>
              <li class="correct"><code>dict</code></li>
              <li><code>tuple</code></li>
              <li>je ne sais pas</li>
            </ul>
          </li>
          <li>
            <p>
              Comment créer une instance d’une classe <code>Animal</code> ?
            </p>
            <ul>
              <li><code>Animal.__init__(self)</code></li>
              <li><code>new Animal</code></li>
              <li><code>new(Animal)</code></li>
              <li class="correct"><code>Animal()</code></li>
              <li>je ne sais pas</li>
            </ul>
          </li>
          <li>
            <p>
              Comment ajouter un élément à une liste <code>numbers</code> qui contient <code>[1, 2, 3]</code> ?
            </p>
            <ul>
              <li><code>add(numbers, 4)</code></li>
              <li><code>numbers += 4</code></li>
              <li><code>numbers(4) = 4</code></li>
              <li class="correct"><code>numbers.append(4)</code></li>
              <li>je ne sais pas</li>
            </ul>
          </li>
      </section>

      <section id="decouverte">
        <h2>Découverte</h2>

        <section id="premieres-commandes">
          <h3>Premières commandes</h3>
          <section class="introduction">
            <p>Temps estimé : 1h.</p>
            <p>
              Nous commençons ce module avec l’installation de l’interpréteur
              Python et la découverte des premières commandes simples, saisies
              directement dans l’interpréteur interactif.
            </p>
          </section>
          <section class="sujet">
            <p>
              Au cours d’une réunion de travail avec votre équipe, certaines
              questions se posent concernant le budget à allouer à un projet.
              Plutôt que d’utiliser une simple calculatrice, vous décidez
              d’utiliser Python pour effectuer ces calculs et bénéficier des
              avantages procurées par un langage de programmation.
            </p>
          </section>
          <section class="questions">
            <h4>Installez Python</h4>
            <aside class="documents">
              <ul>
                <li><a href="installation-et-utilisateur-de-l-interpreteur">FR 1</a></li>
              </ul>
            </aside>
            <ol>
              <li>
                Installez Python et vérifiez que la commande fonctionne
                correctement dans un terminal. Quelle version de Python est
                installée sur votre ordinateur ?
                <aside class="correction">
                  3.x.y, visible lorsque l’on lance <code>python3</code>
                </aside>
              </li>
              <li>
                Comment pouvez-vous quitter l’interpréteur ? Que se passe-t-il
                alors pour toutes les variables que vous avez définies ?
                Relancez l’interpréteur.
                <aside class="correction">
                  <code>exit()</code>, les variables définies sont alors
                  perdues
                </aside>
              </li>
            </ol>
            <h4>Effectuer vos premières opérations</h4>
            <ol>
              <li>
                Votre directrice financière indique le coût pour réaliser ce
                projet est de 1945 € par jour, et elle prévoit environ 12 jours
                de travail. À combien s’élève le coût total ?
                <aside class="correction">
                  <code>1945 * 12</code>
                </aside>
              </li>
              <li>
                Après réflexion, le coût journalier est réévalué à 1965 €. En
                reprenant (sans tout saisir à nouveau !) et en modifiant le
                calcul précédent, à combien s’élève le nouveau coût total ?
                <aside class="correction">
                  <kbd>↑</kbd> puis remplacer <code>4</code> par <code>6</code>
                </aside>
              </li>
              <li>
                Vous voulez enregistrer ce total pour plus tard. Comment faire
                pour retrouver le dernier résultat, et comment faire pour
                l’enregistrer dans une variable appelée <code>total</code> ?
                <aside class="correction">
                  <code>total = _</code>
                </aside>
              </li>
              <li>
                Ce total est à répartir à égalité entre 3 différentes entités
                de votre entreprise, qui prendront chacune un tiers du coût
                total. Enregistrez la part de chaque entreprise dans la
                variable <code>part</code>. Combien vaut-elle ?
                <aside class="correction">
                  <code>part = total / 3</code>
                </aside>
              </li>
            </ol>
            <h4>Créer un petit compte-rendu</h4>
            <ol>
              <li>
                Pour conclure ce calcul, vous souhaitez afficher sur une ligne
                la phrase suivante : « Part pour chaque entité : XX € ».
                Évidemment, vous remplacerez « XX » par le montant de la part,
                en utilisant la variable <code>part</code>.
                <aside class="correction">
                  <code>print(f"Part pour chaque entité : {part} €")</code>
                </aside>
              </li>
              <li>
                Votre équipe préférerait une version plus explicite de ce petit
                compte rendu. Elle souhaiterait que vous affichiez :
                <pre>Budget prévisionnel
===================
- Entité 1 : XX €
- Entité 2 : XX €
- Entité 3 : XX €</pre>
                Affichez ce résultat à l’aide d’une unique commande.
                <aside class="correction">
                  <pre>print(f"""Budget prévisionnel
===================
- Entité 1 : {part} €
- Entité 2 : {part} €
- Entité 3 : {part} €""")
                  </pre>
                </aside>
              </li>
            </ol>
            <h4>Créer un petit script</h4>
            <aside class="documents">
              <ul>
                <li><a href="choix-et-configuration-d-un-editeur">FR 2</a></li>
              </ul>
            </aside>
            <ol>
              <li>
                La réunion est maintenant terminée, mais vous savez que ce
                genre de calcul est assez classique et risque de se répéter à
                l’avenir. Vous décidez donc de sauvegarder ce travail dans un
                script. Choisissez, installez et configurez votre éditeur.
              </li>
              <li>
                Écrivez votre script qui contient cinq commandes :
                <ul>
                  <li>la définition de la variable <code>cout_par_jour</code>,</li>
                  <li>la définition de la variable <code>nombre_de_jours</code>,</li>
                  <li>la définition de la variable <code>total</code> à partir des deux autres variables,</li>
                  <li>la définition de la variable <code>part</code> à partir de la variable <code>total</code>,</li>
                  <li>l’affichage du petit compte-rendu en utilisant la variable <code>part</code>.</li>
                </ul>
                <aside class="correction">
                  <pre>cout_par_jour = 1965
nombre_de_jours = 12
total = cout_par_jour * nombre_de_jours
part = total / 3
print(f"""Budget prévisionnel
===================
- Entité 1 : {part} €
- Entité 2 : {part} €
- Entité 3 : {part} €""")</pre>
                </aside>
              </li>
              <li>
                Lancez votre script et vérifiez que le résultat correspond à
                vos attentes !
              </li>
            </ol>
          </section>
        </section>

        <section id="types-de-base-conditions-et-boucles">
          <h3>Types de base, conditions et boucles</h3>
          <section class="introduction">
            <p>Temps estimé : 3h.</p>
            <p>
              Maintenant que vous savez lancer l’interpréteur Python en mode
              interactif et exécuter des scripts, il est temps d’entrer
              plus en profondeur dans les types et structures de base du
              langage.
            </p>
            <p>
              Dans ce module, nous verrons les différents types natifs les plus
              utilisés. Nous utiliserons également les tests de conditions et
              les boucles pour aborder l’algorithmie et construire nos premiers
              programmes.
            </p>
          </section>
          <section class="sujet">
            <p>
              En attendant que votre projet en C++ compile, vous aimeriez
              occuper votre esprit. Vous vous dites que l’idéal serait d’avoir
              un petit jeu rapide, à portée de main dans le terminal.
            </p>
            <p>
              Cette idée tombe bien ! Pour parfaire vos connaissances en
              Python, quoi de mieux que de se lancer dans le développement d’un
              projet de jeu dans le terminal ?
            </p>
            <p>
              Le jeu que vous décidez de développer est un jeu de mémoire. Les
              lettres de A à H sont mises en désordre. Le but du jeu est de
              trouver la position de la prochaine lettre dans la suite de
              lettres, une par une, jusqu’à afficher « A B C D E F G H » dans
              l’ordre.
            </p>
            <p>
              Tant que la lettre trouvée est après la lettre précédemment
              trouvée (dans l’ordre alphabétique), le jeu continue. Il s’arrête
              dans le cas contraire, et le joueur a perdu.
            </p>
            <p>
              Des exemples de parties gagnées et perdues sont proposées en
              annexe.
            </p>
          </section>
          <section class="questions">
            <h4>Conception et première version</h4>
            <aside class="documents">
              <ul>
                <li><a href="#syntaxe-types-et-instructions">FR 3</a></li>
              </ul>
            </aside>
            <ol>
              <li>
                La première décision à prendre est celle des types à utiliser.
                Notre programme va traiter deux éléments principaux : les
                lettres, et une suite pour les regrouper. Quel type
                utilise-t-on pour stocker chacune des lettres ?
                <aside class="correction">
                  Une chaîne de caractères
                </aside>
              </li>
              <li>
                Pour la suite de lettres, il faut également choisir le bon
                type. On veut à chaque tour demander à l’utilisateur une
                position (entre 0 et 7 au début, par exemple), puis enlever de
                la suite la lettre à cette position. Quel type est adapté pour
                cette suite qui sera modifiée au cours de la partie ?
                <aside class="correction">
                  Une liste
                </aside>
              </li>
              <li>
                Avant de réaliser notre jeu en entier, nous allons commencer
                par une première version simple. Ouvrez votre éditeur de code
                et créez un fichier « game.py » comprenant 5 lignes :
                <ul>
                  <li>
                    affectez à une variable <code>numbers</code> la suite des
                    lettres de A à H, dans l’ordre que vous voulez ;
                  </li>
                  <li>
                    affectez à une variable <code>index</code> un nombre entre
                    0 et 7, qui sera utilisée pour enlever une lettre de la
                    suite ;
                  </li>
                  <li>
                    enlevez de <code>numbers</code> la lettre située à la
                    position <code>index</code>, et mettez cette lettre dans
                    une variable <code>letter</code> ;
                  </li>
                  <li>
                    affichez <code>letter</code> ;
                  </li>
                  <li>
                    affichez <code>numbers</code>.
                  </li>
                </ul>
                Exécutez votre programme et vérifiez que vous obtenez bien le
                résultat attendu : d’abord la lettre enlevée, puis la suite des
                lettres hormis celle enlevée.
                <aside class="correction">
                  <pre>letters = ['B', 'A', 'D', 'E', 'F', 'H', 'G', 'C']
index = 3
letter = letters.pop(index)
print(letter)
print(numbers)</pre>
                </aside>
              </li>
            </ol>
            <h4>Interactivité</h4>
            <ol>
              <li>
                À la place de mettre un nombre en dur dans <code>index</code>, utilisez la fonction
                <a href="https://docs.python.org/3.12/library/functions.html#input"><code>input</code> décrite dans la documentation</a>
                pour demander à l'utilisateur d'entrer le nombre qu'il souhaite. Lancez
                le programme. Quelle erreur obtenez-vous ?
                <aside class="correction">
                  <pre>letters = ['B', 'A', 'D', 'E', 'F', 'H', 'G', 'C']
index = input("Quelle est la position … ? ")
letter = letters.pop(index)
print(letter)
print(numbers)</pre>
                  On obtient une <code>TypeError</code>
                </aside>
              </li>
              <li>
                <code>input</code> renvoie une chaîne de caractères, alors que
                la variable <code>index</code> doit être un entier.
                Heureusement, il est possible de créer un entier qui correspond
                à une chaîne de caractères, par exemple comme ceci :
                <code>int("3")</code>. Utiliser cette méthode pour que
                <code>index</code> soit un entier.
                <aside class="correction">
                  <code>int(input("…"))</code>
                </aside>
              </li>
              <li>
                Exécutez votre programme et vérifiez que vous obtenez bien le
                résultat attendu : on demande à l’utilisateur l’index de la
                lettre à enlever, puis on affiche la lettre enlevée, puis on
                affiche la suite des lettres hormis celle enlevée. Par
                exemple :
                <pre><code>Quelle est la position de la lettre que vous souhaitez enlever ? 3
C
['B', 'H', 'A', 'D', 'F', 'E', 'G']</code></pre>
              </li>
            </ol>
            <h4>Boucle complète</h4>
            <aside class="documents">
              <ul>
                <li><a href="#annexe-2-1">Annexe 1</a></li>
              </ul>
            </aside>
            <ol>
              <li>
                Nous allons maintenant répéter la demande et l’affichage tant
                que la suite de nombre n’est pas vide. Quel type de boucle
                doit-on utiliser ? Exécutez le programme et vérifiez que vous
                pouvez enlever toutes les lettres de la liste avant que le
                programme ne s’arrête.
                <aside class="correction">
                  On utilise une boucle <code>while</code>
                </aside>
              </li>
              <li>
                Nous voulons maintenant vérifier que le joueur ne saisit pas un
                nombre trop grand ou inférieur à 0, et lui reposer la question
                tant que la condition n’est pas vérifiée. Il est possible
                d’effectuer cela avec une boucle infinie dans laquelle on
                demande le nombre à l’utilisateur, et on force la sortie de la
                boucle lorsque la condition est validée. Ajouter cette
                fonctionnalité.
                <aside class="correction">
                  <pre>while True:
    index = int(input('Quelle est la position … ? '))
    if 0 <= index < len(letters):
        break
    print('Nombre incorrect !')</pre>
                </aside>
              </li>
              <li>
                Votre jeu est prêt ! À la place de l’affichage de la liste,
                affichez le nombre de lettres qu’il reste. Ajoutez également un
                message lorsque le joueur a perdu, et un autre lorsque le
                joueur a gagné.
                <aside class="correction">
                  <pre>letters = ['B', 'A', 'D', 'E', 'F', 'H', 'G', 'C']
previous_letter = None
while letters:
    while True:
        index = int(input('Quelle est la position … ? '))
        if 0 <= index < len(letters):
            break
        print('Nombre incorrect !')
    letter = letters.pop(index)
    print(letter)
    if previous_letter and previous_letter > letter:
        print('Vous avez perdu 😢')
        break
    print(f'Il reste {len(letters)} lettre(s)')
    previous_letter = letter
else:
    print('Vous avez gagné 😁')</pre>
                </aside>
              </li>
              <li>
                Vérifiez que résultat correspond aux exemples donnés en
                annexe. Corrigez les problèmes éventuellement rencontrés.
              </li>
            </ol>
          </section>
          <section class="annexes">
            <h4 id="annexe-2-1">Résultats attendus</h4>
            <p>
              Tous les exemples sont donnés avec la suite « B A D E F H G C ».
              Les indices commencent à 0 (la lettre B est à la position 0).
            </p>
            <pre><code>Quelle est la position de la lettre que vous souhaitez enlever ? 2
D
Il reste 7 lettre(s)
Quelle est la position de la lettre que vous souhaitez enlever ? 3
F
Il reste 6 lettre(s)
Quelle est la position de la lettre que vous souhaitez enlever ? 3
H
Il reste 5 lettre(s)
Quelle est la position de la lettre que vous souhaitez enlever ? 2
E
Vous avez perdu 😢</code></pre>
            <pre><code>Quelle est la position de la lettre que vous souhaitez enlever ? 1
A
Il reste 7 lettre(s)
Quelle est la position de la lettre que vous souhaitez enlever ? 0
B
Il reste 6 lettre(s)
Quelle est la position de la lettre que vous souhaitez enlever ? 5
C
Il reste 5 lettre(s)
Quelle est la position de la lettre que vous souhaitez enlever ? 0
D
Il reste 4 lettre(s)
Quelle est la position de la lettre que vous souhaitez enlever ? 0
E
Il reste 3 lettre(s)
Quelle est la position de la lettre que vous souhaitez enlever ? 0
F
Il reste 2 lettre(s)
Quelle est la position de la lettre que vous souhaitez enlever ? 1
G
Il reste 1 lettre(s)
Quelle est la position de la lettre que vous souhaitez enlever ? 0
H
Il reste 0 lettre(s)
Vous avez gagné 😁</code></pre>
            <pre><code>Quelle est la position de la lettre que vous souhaitez enlever ? 0
B
Il reste 7 lettre(s)
Quelle est la position de la lettre que vous souhaitez enlever ? 6
C
Il reste 6 lettre(s)
Quelle est la position de la lettre que vous souhaitez enlever ? 1
D
Il reste 5 lettre(s)
Quelle est la position de la lettre que vous souhaitez enlever ? 1
E
Il reste 4 lettre(s)
Quelle est la position de la lettre que vous souhaitez enlever ? 1
F
Il reste 3 lettre(s)
Quelle est la position de la lettre que vous souhaitez enlever ? 2
G
Il reste 2 lettre(s)
Quelle est la position de la lettre que vous souhaitez enlever ? 1
H
Il reste 1 lettre(s)
Quelle est la position de la lettre que vous souhaitez enlever ? 0
A
Vous avez perdu 😢</code></pre>
            <pre><code>Quelle est la position de la lettre que vous souhaitez enlever ? 1
A
Il reste 7 lettre(s)
Quelle est la position de la lettre que vous souhaitez enlever ? 1
D
Il reste 6 lettre(s)
Quelle est la position de la lettre que vous souhaitez enlever ? 1
E
Il reste 5 lettre(s)
Quelle est la position de la lettre que vous souhaitez enlever ? -1
Nombre incorrect !
Quelle est la position de la lettre que vous souhaitez enlever ? 1000
Nombre incorrect !
Quelle est la position de la lettre que vous souhaitez enlever ? 5
Nombre incorrect !
Quelle est la position de la lettre que vous souhaitez enlever ? 0
B
Vous avez perdu 😢</code></pre>
          </section>
        </section>

        <section id="fonctions-et-classes">
          <h3>Fonctions et classes</h3>
          <section class="introduction">
            <p>Temps estimé : 3h.</p>
            <p>
              Pour une tâche simple, un petit script est souvent suffisant,
              avec quelques conditions et boucles si nécessaire. Mais
              rapidement, il devient utile de regrouper des fonctionnalités
              génériques dans des fonctions, afin de garder un fil d’exécution
              principal plus lisible en appelant des fonctions de haut niveau.
            </p>
            <p>
              Lorsque l’on veut représenter des entités ou des concepts du
              monde physique, une autre abstraction est également utilisée : la
              programmation orientée objet. Ce paradigme très répandu, que
              Python implémente, permet de regrouper les informations et les
              comportements d’une entité au même endroit dans le code.
            </p>
            <p>
              Dans ce module, nous apprendrons à structurer notre code en
              utilisant des fonctions, puis des classes, afin de mieux
              comprendre l’utilité de ces abstractions et de voir leurs
              spécificités en Python.
            </p>
          </section>
          <section class="sujet">
            <p>
              La mission que votre entreprise vous a assignée consiste à
              accompagner une petite ferme dans la mise en place d’un système
              d’information. Et la première information que vous devez gérer
              est la liste des animaux.
            </p>
            <p>
              Dans ce but, vous développez un prototype d’application simple
              permettant d’accéder aux informations des animaux. Ce prototype
              est développé au fur et à mesure des demandes du client, avec des
              besoins et une complexité croissante.
            </p>
            <p>
              Ce prototype est l’occasion rêvée pour construire une architecture
              solide pour l’application qui sera développée dans le futur !
            </p>
          </section>
          <section class="questions">
            <h4>Structures de données</h4>
            <aside class="documents">
              <ul>
                <li><a href="#syntaxe-types-et-instructions">FR 3</a></li>
              </ul>
            </aside>
            <ol>
              <li>
                Dans votre éditeur de code, vous créez un fichier « ferme.py »,
                qui contiendra votre prototype. La première demande de votre
                client est de créer une liste d’animaux. Vous créez donc une
                liste <code>animaux</code> vide au début de votre fichier.
                <aside class="correction">
                  <pre>animaux = []</pre>
                </aside>
              </li>
              <li>
                Pour répondre à la demande du fermier, plusieurs informations doivent
                être renseignées pour chaque animal : l’espèce de l’animal, l’âge et le
                nom. Quelle structure de donnée simple vous permet d’associer des clés
                (<code>"espèce"</code>, <code>"âge"</code>,
                <code>"nom"</code>) avec les valeurs correspondantes
                (<code>"vache"</code>, <code>6</code>, <code>"Marguerite"</code>
                par exemple) ?
                <aside class="correction">
                  Un dictionnaire
                </aside>
              </li>
              <li>
                Dans la liste, le fermier vous demande d’inclure pour l’instant 5 animaux :
                <ul>
                  <li>Marguerite, une vache de 5 ans,</li>
                  <li>Hortense, une vache de 7 ans,</li>
                  <li>Caramel, un veau de 1 an,</li>
                  <li>Coco, une poule de 3 ans,</li>
                  <li>Blanche, une poule de 2 ans.</li>
                </ul>
                Vous insérez donc chacun de ces animaux dans votre liste, en
                utilisant la structure déterminée auparavant. Le nom et l’espèce
                sont des chaînes de caractères, l’âge est un entier qui
                représente le nombre d’années.
                <aside class="correction">
                  <pre><code>animaux = [
    {"espèce": "vache", "âge": 6, "nom": "Marguerite"},
    {"espèce": "vache", "âge": 7, "nom": "Hortense"},
    {"espèce": "veau", "âge": 1, "nom": "Caramel"},
    {"espèce": "poule", "âge": 3, "nom": "Coco"},
    {"espèce": "poule", "âge": 2, "nom": "Blanche"},
]</code></pre>
                </aside>
              </li>
              <li>
                Dans votre prototype, faites une boucle pour parcourir vos
                animaux. Pour chaque animal, affichez les informations comme suit :
                <pre>Nom : Marguerite
Espèce : vache
Âge : 5 an(s)</pre>
                <aside class="correction">
                  <pre><code>for animal in animaux:
    print(f"Nom : {animal['nom']}")
    print(f"Espèce : {animal['espèce']}")
    print(f"Âge : {animal['âge']} an(s)")</code></pre>
              </li>
            </ol>
            <h4>Fonctions</h4>
            <aside class="documents">
              <ul>
                <li><a href="#fonctions">FR 4</a></li>
                <li><a href="#annexe-3-1">Annexe 1</a></li>
              </ul>
            </aside>
            <ol>
              <li>
                Le fermier est content de cette première liste. Il aimerait
                dans le futur pouvoir afficher le nombre total d’animaux,
                lister d’abord les vaches (y compris le veau), puis les poules,
                dans deux parties différentes. Quels problèmes cela pose-t-il ?
                <aside class="correction">
                  Il faut réussir à grouper les animaux par espèce, et il faut
                  que l’on arrive à stocker l’information que les veaux sont
                  des vaches
                </aside>
              </li>
              <li>
                Il existe différentes solutions pour atteindre cet objectif. La
                première possibilité que vous testez est de changer l’espèce
                de Caramel en « vache », afin que l’on ait bien la
                même valeur pour les vaches et les veaux (qui sont en réalité
                des jeunes vaches, bien sûr !) Relancez votre programme, qui
                doit maintenant dire que Caramel est une vache.
                <aside class="correction">
                  <code>{"espèce": "vache", "âge": 1, "nom": "Caramel"},</code>
                </aside>
              </li>
              <li>
                Vous pouvez désormais afficher les vaches et les poules
                séparément. Imbriquez votre boucle <code>for</code> dans une autre
                boucle <code>for</code>, qui met <code>"vache"</code>
                puis <code>"poule"</code> dans une variable <code>espece</code>,
                qui affiche cette variable, avant d’afficher les informations
                des animaux correspondant à cette
                <code>espece</code>. Vous devez obtenir quelque chose comme :
                <pre><code>Espèce : vache
- Marguerite, 5 an(s)
- Hortense, 7 an(s)
- Caramel, 1 an(s)

Espèce : poule
- Coco, 3 an(s)
- Blanche, 3 an(s)</code></pre>
                <aside class="correction">
                  <pre>for espece in ("vache", "poule"):
    print(f"Espèce : {espece}")
    for animal in animaux:
        if animal['espèce'] == espece:
            print(f"- {animal['nom']}, {animal['âge']} an(s)")
    print()</pre>
                </aside>
              </li>
              <li>
                Pour gagner en lisibilité, vous décidez de créer une
                fonction <code>afficher_animaux(animaux, espece)</code> qui
                affiche la liste des animaux d’une espèce donnée. À la place de la
                boucle imbriquée, vous appelez donc cette nouvelle fonction. Le
                résultat doit être le même.
                <aside class="correction">
                  <pre>def afficher_animaux(animaux, espece):
    for animal in animaux:
        if animal['espèce'] == espece:
            print(f"- {animal['nom']}, {animal['âge']} an(s)")

for espèce in ("vache", "poule"):
    print(f"Espèce : {espèce}")
    afficher_animaux(animaux, espèce)
    print()</pre>
                  </pre>
                </aside>
              </li>
              <li>
                Vous décidez enfin d’accéder à la dernière demande faite par le
                fermier : afficher le nombre total d’animaux avant la boucle.
                <aside class="correction">
                  <pre>print(f"Nombre d’animaux : {len(animaux)}")</pre>
                </aside>
              </li>
              <li>
                Le fermier est ravi ! Un dernier problème persiste cependant :
                il est difficile de discerner les jeunes animaux des adultes.
                Vous décidez donc d’afficher la mention « jeune animal » pour
                les animaux de 2 ans ou moins, à la place de leur âge.
                <aside class="correction">
                  <pre>if animal['âge'] <= 2:
    print(f"- {animal['nom']}, {animal['âge']} an(s)")
else:
    print(f"- {animal['nom']}, jeune animal")</pre>
                </aside>
              </li>
              <li>
                L’affichage d’un animal est maintenant plus complexe, avec une
                condition. Vous décidez donc de sortir ce code dans une
                fonction <code>afficher_animal(animal)</code>. Le résultat
                final est le suivant :
                <pre>Nombre d’animaux : 5

Espèce : vache
- Marguerite, 5 an(s)
- Hortense, 7 an(s)
- Caramel, jeune animal

Espèce : poule
- Coco, 3 an(s)
- Blanche, 3 an(s)</pre>
                <aside class="correction">
                  <pre>animaux = [
    {"espèce": "vache", "âge": 6, "nom": "Marguerite"},
    {"espèce": "vache", "âge": 7, "nom": "Hortense"},
    {"espèce": "vache", "âge": 1, "nom": "Caramel"},
    {"espèce": "poule", "âge": 3, "nom": "Coco"},
    {"espèce": "poule", "âge": 2, "nom": "Blanche"},
]

def afficher_animal(animal):
    if animal['âge'] <= 2:
        print(f"- {animal['nom']}, {animal['âge']} an(s)")
    else:
	print(f"- {animal['nom']}, jeune animal")

def afficher_animaux(animaux, espece):
    for animal in animaux:
        if animal['espèce'] == espece:
            afficher_animal(animal)

print(f"Nombre d’animaux : {len(animaux)}\n")
for espece in ("vache", "poule"):
    print(f"Espèce : {espece}")
    afficher_animaux(animaux, espece)
    print()</pre>
              </li>
            </ol>
            <h4>Classes</h4>
            <aside class="documents">
              <ul>
                <li><a href="#programmation-objet">FR 5</a></li>
                <li><a href="#annexe-3-2">Annexe 2</a></li>
              </ul>
            </aside>
            <ol>
              <li>
                Le fermier est presque convaincu par votre prototype ! Il
                souhaiterait que vous finalisiez sa structure pour qu’il puisse
                à terme stocker plus d’animaux et ajouter de nouvelles
                fonctionnalités. Pour assurer la pérennité du projet, vous
                décidez donc de remplacer votre structure simple par une
                classe <code>Animal</code>. Créez donc cette classe, qui
                contient pour l’instant les trois
                attributs <code>espece</code>, <code>age</code>
                et <code>nom</code> enregistrés à l’instanciation. Modifiez
                votre code pour qu’il utilise des instances
                de <code>Animal</code>.
                <aside class="correction">
                  <pre>class Animal:
    def __init__(self, espece, age, nom):
        self.espece = espece
        self.age = age
        self.nom = nom

animaux = [
    Animal("vache", 5, 'Marguerite'),
    Animal("vache", 7, 'Hortense'),
    Animal("vache", 1, 'Caramel'),
    Animal("poule", 3, 'Coco'),
    Animal("poule", 2, 'Blanche'),
]

def afficher_animal(animal):
    if animal.age <= 2:
        print(f"- {animal.nom}, {animal.age} an(s)")
    else:
	print(f"- {animal.nom}, jeune animal")

def afficher_animaux(animaux, espece):
    for animal in animaux:
        if animal.espece == espece:
            afficher_animal(animal)

print(f"Nombre d’animaux : {len(animaux)}\n")
for espece in ("vache", "poule"):
    print(f"Espèce : {espece}")
    afficher_animaux(animaux, espece)
    print()</pre>
                </aside>
              </li>
              <li>
                Il va désormais être plus simple de structurer votre code.
                Transformez la fonction <code>afficher_animal(animal)</code> en
                méthode <code>afficher(self)</code> de la
                classe <code>Animal</code>. Modifiez votre code pour qu’il
                utilise cette méthode.
                <aside class="correction">
                  <pre>def afficher(self):
    if self.age <= 2:
        print(f"- {self.nom}, {self.age} an(s)")
    else:
        print(f"- {self.nom}, jeune animal")</pre>
                </aside>
              </li>
              <li>
                Nous allons ajouter les dernières finitions à notre prototype.
                Afin de pouvoir différencier plus facilement les espèces, nous
                allons créer les classes <code>Poule</code> et
                <code>Vache</code> qui héritent de <code>Animal</code>. Ces
                classes ne contiendront pour l’instant qu’un attribut de
                classe : <code>espece</code>, qui est donc obsolète dans la
                classe <code>Animal</code>. Modifiez votre code pour qu’il
                utilise ces classes.
                <aside class="correction">
                  <pre>class Animal:
    def __init__(self, age, nom):
        self.age = age
        self.nom = nom

    def afficher(self):
        if self.age <= 2:
            print(f"- {self.nom}, {self.age} an(s)")
        else:
            print(f"- {self.nom}, jeune animal")

class Poule(Animal):
    espece = 'poule'

class Vache(Animal):
    espece = 'vache'

animaux = [
    Vache(5, 'Marguerite'),
    Vache(7, 'Hortense'),
    Vache(1, 'Caramel'),
    Poule(3, 'Coco'),
    Poule(2, 'Blanche'),
]</pre>
                </aside>
              </li>
              <li>
                Nous pouvons maintenant gérer l’affichage des animaux plus
                finement.
                <ul>
                  <li>
                    Changez <code>Animal.afficher</code> pour qu’il
                    affiche simplement le nom et l’âge, sans gérer les jeunes
                    animaux.
                  </li>
                  <li>
                    Créez une méthode <code>Poule.afficher</code> qui affiche
                    le nom de l’animal et « poussin » si l’animal a 1 an au
                    plus, ou qui appelle <code>Animal.afficher</code> sinon.
                  </li>
                  <li>
                    Créez une méthode <code>Vache.afficher</code> qui affiche
                    le nom de l’animal et « veau » si l’animal a 2 ans au plus,
                    ou qui appelle <code>Animal.afficher</code> sinon.
                  </li>
                </ul>
                <aside class="correction">
                  <pre><code>class Animal:
    def __init__(self, age, nom):
        self.age = age
        self.nom = nom

    def afficher(self):
        print(f'- {self.nom}, {self.age} an(s)')


class Poule(Animal):
    espece = 'poule'

    def afficher(self):
        if self.age <= 1:
            print(f'- {self.nom}, poussin')
        else:
            super().afficher()


class Vache(Animal):
    espece = 'vache'

    def afficher(self):
        if self.age <= 2:
            print(f'- {self.nom}, veau')
        else:
            super().afficher()</code></pre>
                </aside>
              </li>
              <li>
                Un nouveau poussin appelé « Pioupiou » vient de naître !
                Ajoutez-le à la liste des <code>animaux</code>, et vérifiez que
                l’affichage correspond à ceci :
                <pre>Nombre d’animaux : 6

Espèce : vache
- Marguerite, 5 an(s)
- Hortense, 7 an(s)
- Caramel, veau

Espèce : poule
- Coco, 3 an(s)
- Blanche, 2 an(s)
- Pioupiou, poussin</pre>
                <aside class="correction">
                  <pre><code>class Animal:
    def __init__(self, age, nom):
        self.age = age
        self.nom = nom

    def afficher(self):
        print(f'- {self.nom}, {self.age} an(s)')

class Poule(Animal):
    espece = 'poule'

    def afficher(self):
        if self.age <= 1:
            print(f'- {self.nom}, poussin')
        else:
            super().afficher()

class Vache(Animal):
    espece = 'vache'

    def afficher(self):
        if self.age <= 2:
            print(f'- {self.nom}, veau')
        else:
            super().afficher()

animaux = [
    Vache(5, 'Marguerite'),
    Vache(7, 'Hortense'),
    Vache(1, 'Caramel'),
    Poule(3, 'Coco'),
    Poule(2, 'Blanche'),
    Poule(0, 'Pioupiou'),
]

def afficher_animaux(animaux, espece):
    for animal in animaux:
        if espece == animal.espece:
            animal.afficher()

print(f'Nombre d’animaux : {len(animaux)}\n')
for espece in ('vache', 'poule'):
    print(f'Type d’animal : {espece}')
    afficher_animaux(animaux, espece)
    print()</code></pre>
                </aside>
              </li>
            </ol>
          </section>
          <section class="annexes">
            <h4 id="annexe-3-1">Structure du code avec fonctions</h4>
            <pre><code>animaux = [
    {'espèce': 'vache', 'âge': 5, 'nom': 'Marguerite'},
    …
]

def afficher_animal(animal):
    if …:
        print(…)
    else:
        print(…)


def afficher_animaux(animaux, espece):
    for …:
        if …:
            afficher_animal(animal)


print(f'Nombre…')
for …:
    print(f'Espèce…')
    afficher_animaux(animaux, espece)
    print()</code></pre>

            <h4 id="annexe-3-2">Structure du code avec classes</h4>
            <pre><code>class Animal:
    def __init__(self, age, nom):
        …

    def afficher(self):
        …


class Poule(Animal):
    espece = 'poule'

    def afficher(self):
        if …:
            …
        else:
            super()…


class Vache(Animal):
    espece = 'vache'

    def afficher(self):
        if …:
            …
        else:
            super()…


animaux = [
    Vache(5, 'Marguerite'),
    …,
    Poule(0, 'Pioupiou'),
]

def afficher_animaux(animaux, espece):
    for …:
        if …:
            animal.afficher()


print(f'Nombre…')
for …:
    print(f'Espèce…')
    afficher_animaux(animaux, espece)
    print()</code></pre>
          </section>
        </section>

        <section id="bibliotheque-standard-et-modules-externes">
          <h3>Bibliothèque standard et modules externes</h3>
          <section class="introduction">
            <p>Temps estimé : 3h.</p>
            <p>
              Python propose un grand nombre de fonctionnalités grâce à des
              modules directement fournis avec l’interpréteur. Sans rien avoir
              à installer, grâce aux modules de la bibliothèque standard, il
              vous est possible de manipuler des dates, de faire de la
              trigonométrie, d’accéder aux informations de votre système, ou
              d’utiliser les protocoles réseau les plus courants.
            </p>
            <p>
              D’autres modules sont fournis en dehors de la bibliothèque
              standard. Après installation, ils vous offriront un éventail très
              large de possibilités dans des domaines extrêmement variés… à
              condition de bien gérer vos dépendances.
            </p>
            <p>
              Cette étape a pour but de vous familiariser avec les imports de
              modules. Que ce soit au sein de vos programmes séparés en
              différents fichiers, pour utiliser la bibliothèque standard ou
              pour utiliser des bibliothèques tierces, vous apprendrez à
              importer des modules et à utiliser les fonctionnalités qu’ils
              pourront vous apporter.
            </p>
          </section>
          <section class="sujet">
            <p>
              Votre entreprise a été missionnée pour créer un logiciel éducatif
              pour les enfants, intitulé « FunMath ». Avant de commencer le
              développement de ce logiciel, elle aimerait étudier la
              possibilité de l’écrire en Python.
            </p>
            <p>
              Votre cheffe de projet vous propose de réaliser une bibliothèque
              qui permet d’effectuer des opérations mathématiques simples, afin
              d’avoir une meilleure idée de ce qui est réalisable. À terme, si
              tout fonctionne correctement, votre bibliothèque sera utilisée
              dans l’application finale.
            </p>
            <p>
              Vous vous lancez donc dans l’écriture de cette bibliothèque. Vous
              créez également un petit script qui servira de démonstration à
              votre cheffe, en espérant que vous saurez la convaincre !
            </p>
          </section>
          <section class="questions">
            <h4>Créer votre première bibliothèque</h4>
            <aside class="documents">
              <ul>
                <li><a href="#modules-et-imports">FR 6</a></li>
              </ul>
            </aside>
            <ol>
              <li>
                Pour commencer votre projet, vous créez un fichier
                « funmath.py » dans lequel vous créez deux
                fonctions : <code>somme(nombre_1, nombre_2)</code> qui renvoie
                « nombre_1 + nombre_2 », et <code>produit(nombre_1, nombre_2)</code>
                qui renvoie « nombre_1 × nombre_2 ».
              </li>
              <li>
                Vous souhaitez tester votre module, pour vérifier que tout
                fonctionne correctement. Vous créez un fichier « script.py »,
                dans lequel vous importez le module « funmath » et vous
                affichez le résultat de <code>funmath.somme(2, 3)</code>
                et <code>funmath.produit(2, 3)</code>. Combien font la somme et
                le produit de 2 et 3 (c’est une question à votre portée) ?
              </li>
              <li>
                Outre les opérations de bases, vous aimeriez avoir les calculs
                d’aires pour les carrés et les cercles. Dans « funmath.py »,
                vous créez donc deux fonctions <code>aire_carre(longueur)</code>
                et <code>aire_cercle(rayon)</code> qui renvoient la valeur de
                ces aires. Pour le cercle, vous aurez besoin d’une variable
                <code>pi</code>, que vous pouvez définir au début de votre
                fichier, approximée à <code>3.14</code>. Dans « script.py »,
                après la somme et le produit, vous décidez d’afficher pi,
                l’aire d’un carré de longueur 3 et l’aire d’un cercle de rayon
                3. Quelles valeurs obtenez-vous ?
              </li>
              <li>
                Vous avez conscience qu’à terme, beaucoup de fonctions seront
                disponibles dans votre application. Il est temps de mieux
                structurer votre bibliothèque ! Vous décidez donc de remplacer
                votre fichier « funmath.py » par un dossier « funmath » qui
                contient 3 fichiers :
                <ul>
                  <li>
                    « funmath/algebre.py » contenant <code>somme</code>
                    et <code>produit</code>,
                  </li>
                  <li>
                    « funmath/geometrie.py » contenant <code>pi</code>, <code>aire_carre</code>
                    et <code>aire_cercle</code>,
                  </li>
                  <li>
                    « funmath/__init__.py » contenant les imports relatifs de <code>somme</code>,
                    <code>produit</code>, <code>pi</code>, <code>aire_carre</code>
                    et <code>aire_cercle</code> (pour qu’on puisse par exemple utiliser
                    <code>funmath.somme</code>, comme auparavant).
                  </li>
                </ul>
                Vérifiez que « script.py » fonctionne toujours, sans la moindre
                modification !
              </li>
            </ol>
            <h4>Utiliser la bibliothèque standard</h4>
            <aside class="documents">
              <ul>
                <li><a href="#bibliotheque-standard">FR 7</a></li>
                <li><a href="#annexe-4-1">Annexe 1</a></li>
              </ul>
            </aside>
            <ol>
              <li>
                Votre première version est concluante, mais il reste beaucoup
                de travail ! Vous décidez d’utiliser la
                bibliothèque standard pour améliorer et développer de nouvelles
                fonctionnalités. Votre première amélioration est d’utiliser la
                valeur de <code>pi</code> venant du module <code>math</code>, à
                la place de notre approximation. Importez <code>pi</code> dans
                « funmath/geometrie.py », à la place de la variable
                <code>pi</code>. Vérifiez que le script fonctionne, avec des
                valeurs plus précises !
              </li>
              <li>
                Une nouvelle fonctionnalité à ajouter concerne des opérations
                avec les dates. Vous décidez de créer un nouveau fichier
                « funmath/temps.py » qui contient une fonction
                <code>nombre_jours(annee_1, mois_1, jour_1, annee_2, mois_2, jour_2)</code>.
                Cette fonction renvoie un entier correspondant au nombre de
                jours entre deux dates. Pour cela, vous utilisez le module
                <code>datetime</code>, et la possibilité de
                faire une différence (avec <code>-</code>) entre deux objets
                <code>datetime.date</code>.
              </li>
              <li>
                Dans votre script, vous décidez d’afficher le nombre de jours
                entre votre date de naissance et aujourd’hui. Vous souhaitez utiliser
                <code>funmath.nombre_jours</code>, vous ajoutez donc un import
                dans « funmath/__init__.py ». Combien de jours a duré votre vie ?
              </li>
            </ol>
            <h4>Utiliser des modules externes</h4>
            <aside class="documents">
              <ul>
                <li><a href="#environnements-virtuels">FR 8</a></li>
              </ul>
            </aside>
            <ol>
              <li>
                La qualité et la quantité de fonctionnalités de votre module
                sont désormais suffisantes pour une petite démonstration. Vous
                souhaitez améliorer votre script pour qu’il soit un peu plus
                attractif. Mettons quelques couleurs dans ce terminal ! Pour
                cela, rien n’est disponible dans la bibliothèque standard, mais
                nous trouverons bien une bibliothèque tierce. Vous commencez
                par créer un environnement virtuel. Après activation, vous
                affichez le chemin complet vers <code>python3</code>. Est-il
                bien dans votre environnement virutel ?
              </li>
              <li>
                Après quelques recherches, vous décidez d’utiliser la bibliothèque
                <a href="https://rich.readthedocs.io/">Rich</a> pour mettre
                de la couleur dans votre script. Après avoir vérifié que votre
                environnement virtuel est activé, vous
                installez <code>rich</code>. Pour vérifier que tout va bien,
                vous lancez l’interpréteur, importez <code>rich</code>, et
                vérifiez que vous pouvez afficher la largeur de votre terminal
                avec <code>rich.get_console().width</code>.
              </li>
              <li>
                Il est temps de mettre des couleurs dans votre script ! Grâce à
                la documentation de la fonction <code>rich.print</code> et
                du module <code>rich.panel</code>, vous arrivez à ce résultat :
                <pre><span class="rouge">╭─────────╮
│ Algèbre │
╰─────────╯</span>
<span class="vert">2+3</span> = <span class="bleu">5</span>
<span class="vert">2×3</span> = <span class="bleu">6</span>

<span class="rouge">╭───────────╮
│ Géométrie │
╰───────────╯</span>
<span class="vert">π</span> = <span class="bleu">3.141592653589793</span>
<span class="vert">Aire d’un carré de côté 3</span> = <span class="bleu">9</span>
<span class="vert">Aire d’un cercle de rayon 3</span> = <span class="bleu">28.274333882308138</span>

<span class="rouge">╭───────╮
│ Temps │
╰───────╯</span>
<span class="vert">Nombre de jours que j’ai vécus</span> = <span class="bleu">9999</span></pre>
              </li>
            </ol>
          </section>
          <section class="annexes">
            <h4 id="annexe-4-1">Exemple de structure du code</h4>
            <figure class="fichier">
              <figcaption><code>script.py</code></figcaption>
              <pre><code><span class="vert">from</span> rich <span class="vert">import</span> print
<span class="vert">from</span> rich.panel <span class="vert">import</span> Panel

<span class="vert">import</span> funmath

print(…)  <span class="gris"># Titre algèbre</span>
print(…)  <span class="gris"># 2+3</span>
print(…)  <span class="gris"># 2×3</span>

print()
print(…)  <span class="gris"># Titre géométrie</span>
print(…)  <span class="gris"># Pi</span>
print(…)  <span class="gris"># Carré</span>
print(…)  <span class="gris"># Cercle</span>

print()
print(…)  <span class="gris"># Titre temps</span>
print(…)  <span class="gris"># Jours</span></code></pre>
            </figure>
            <figure class="fichier">
              <figcaption><code>funmath/__init__.py</code></figcaption>
              <pre><code><span class="vert">from</span> .algebre <span class="vert">import</span> …
<span class="vert">from</span> .geometrie <span class="vert">import</span> …
<span class="vert">from</span> .temps <span class="vert">import</span> …</code></pre>
            </figure>
            <figure class="fichier">
              <figcaption><code>funmath/algebre.py</code></figcaption>
              <pre><code><span class="vert">def</span> somme(nombre_1, nombre_2):
    …

<span class="vert">def</span> produit(nombre_1, nombre_2):
    …</code></pre>
            </figure>
            <figure class="fichier">
              <figcaption><code>funmath/geometrie.py</code></figcaption>
              <pre><code><span class="vert">from</span> math <span class="vert">import</span> …

<span class="vert">def</span> aire_carre(longueur):
    …

<span class="vert">def</span> aire_cercle(rayon):
    …</code></pre>
            </figure>
            <figure class="fichier">
              <figcaption><code>funmath/temps.py</code></figcaption>
              <pre><code><span class="vert">from</span> datetime <span class="vert">import</span> date

<span class="vert">def</span> nombre_jours(annee_1, mois_1, jour_1, annee_2, mois_2, jour_2):
    date_1 = …
    date_2 = …
    delta = …
    <span class="vert">return</span> …</code></pre>
            </figure>
          </section>
          <section>
            <h4>Correction</h4>
            <figure class="fichier">
              <figcaption><code>script.py</code></figcaption>
              <pre>from rich import print
from rich.panel import Panel

import funmath

print(Panel.fit('Algèbre', style='red'))
print(f'[green]2+3[/green] = {funmath.somme(2, 3)}')
print(f'[green]2×3[/green] = {funmath.produit(2, 3)}')

print()
print(Panel.fit('Géométrie', style='red'))
print(f'[green]π[/green] = {funmath.pi}')
print(f'[green]Carré[/green] = {funmath.aire_carre(3)}')
print(f'[green]Cercle[/green] = {funmath.aire_cercle(3)}')

print()
print(Panel.fit('Temps', style='red'))
print(
    '[green]Jours[/green] = '
    f'{funmath.nombre_jours(1994, 12, 24, 2024, 2, 29)}'
)</pre>
            </figure>
            <figure class="fichier">
              <figcaption><code>funmath/__init__.py</code></figcaption>
              <pre>from .algebre import produit, somme
from .geometrie import aire_carre, aire_cercle, pi
from .temps import nombre_jours</pre>
            </figure>
            <figure class="fichier">
              <figcaption><code>funmath/algebre.py</code></figcaption>
              <pre>def somme(nombre_1, nombre_2):
    return nombre_1 + nombre_2

def produit(nombre_1, nombre_2):
    return nombre_1 * nombre_2</pre>
            </figure>
            <figure class="fichier">
              <figcaption><code>funmath/geometrie.py</code></figcaption>
              <pre>from math import pi

def aire_carre(longueur):
    return longueur * longueur

def aire_cercle(rayon):
    return rayon * rayon * pi</pre>
            </figure>
            <figure class="fichier">
              <figcaption><code>funmath/temps.py</code></figcaption>
              <pre>from datetime import date

def nombre_jours(annee_1, mois_1, jour_1, annee_2, mois_2, jour_2):
    date_1 = date(annee_1, mois_1, jour_1)
    date_2 = date(annee_2, mois_2, jour_2)
    delta = date_2 - date_1
    return delta.days</pre>
            </figure>
          </section>
        </section>

        <section id="programmation-web">
          <h3>Programmation web</h3>
          <section class="introduction">
            <p>Temps estimé : 4h.</p>
            <p>
              Python est un langage utilisé dans un très large champ
              d’applications. Le développement web est l’un des axes sur
              lesquels il excelle, du tout petit site personnel aux énormes
              plateformes en ligne comme Instagram ou Spotify.
            </p>
            <p>
              Dans ce module, nous aborderons le web avec Python grâce à
              l’utilisation du framework Flask. Nous étudierons la structure
              d’applications web simples, avec un accent particulier mis sur
              certains vecteurs d’attaque et quelques bonnes pratiques de
              sécurité.
            </p>
          </section>
          <section class="sujet">
            <p>
              Avec votre grande expérience en Python, vous êtes chargé de
              construire le blog de votre entreprise.
            </p>
            <p>
              Vous encadrez un stagiaire qui a travaillé sur une ébauche de
              site. Il vous présente cette première version afin que vous
              puissiez faire des retours sur son travail. L’architecture
              globale et la documentation sont très bonnes, mais quelques
              problèmes importants nécessitent d’être corrigés.
            </p>
          </section>
          <section class="questions">
            <h4>Récupérer et lancer l’application du stagiaire</h4>
            <aside class="documents">
              <ul>
                <li><a href="#environnements-virtuels">FR 8</a></li>
                <li><a href="#flask">FR 9</a></li>
              </ul>
            </aside>
            <ol>
              <li>
                Vous téléchargez et décompressez l’archive <todo>lien</todo>
                contenant le travail de votre stagiaire. Vérifiez que vous
                avez, dans votre dossier de travail, un fichier « README.md »,
                un fichier « requirements.txt » et un dossier « blog ».
              </li>
              <li>
                Dans votre dossier de travail, vous créez un environnement
                virtuel. Vous avez donc un dossier « venv » au même niveau que
                « README.md » et « blog ».
                <aside class="correction">
                  <pre>python3 -m venv venv</pre>
                </aside>
              </li>
              <li>
                Vous lancez votre application en suivant les instructions du
                fichier « README.md ». Vous devez voir l’URL
                <a href="http://127.0.0.1:5000">http://127.0.0.1:5000</a>
                s’afficher dans le terminal. Vous allez sur cette adresse avec
                votre navigateur pour vérifier que la page d’accueil s’affiche.
                <aside class="correction">
                  <pre>source venv/bin/activate # Sous macOS ou Linux
venv\Scripts\activate.bat # Sous Windows
(venv) pip install -r requirements.txt
(venv) flask --app blog run --debug</pre>
                </aside>
              </li>
              <li>
                Un message de <em>warning</em> s’affiche en rouge. Que vous
                dit-il ? Vous trouvez dans
                <a href="https://flask.palletsprojects.com/">la documentation
                de Flask</a> quelques informations supplémentaires, en
                recherchant « run the development server » dans la
                documentation. Le serveur de développement pourrait-il poser un
                problème de sécurité s’il était utilisé en production ?
                <aside class="correction">
                  <pre>WARNING: This is a development server.
Do not use it in a production deployment.
Use a production WSGI server instead.</pre>
                  Oui, le serveur de développement peut poser un
                  <a href="https://flask.palletsprojects.com/en/3.0.x/cli/#run-the-development-server">problème de sécurité</a>
                </aside>
              </li>
              <li>
                Vous commencer à tester le blog dans votre navigateur. Vous
                vous connectez en utilisant l’identifiant « login » et le mot
                de passe « password », puis créez un nouvel article. Quel
                problème gênant apparaît après avoir crée plusieurs articles ?
                (Nous résoudrons cette limitation plus tard.)
                <aside class="correction">
                  Le titre des articles créés est toujours « Titre »
                </aside>
              </li>
            </ol>
            <h4>Découvrir le fonctionnement de Flask</h4>
            <ol>
              <li>
                Dans quels fichiers se situent les différents éléments de
                votre application web :
                <ul>
                  <li>le HTML,</li>
                  <li>le CSS,</li>
                  <li>la liste des URL de l’application et le code qui leur est associé,</li>
                  <li>le code permettant d’accéder à base de données ?</li>
                </ul>
                <aside class="correction">
                  Le HTML est dans « blog/templates », le CSS est dans
                  « blog/static », la liste des URL est dans
                  « blog/__init__.py », le code de la base de données est dans
                  « blog/db.py ».
                </aside>
              </li>
              <li>
                Dans quel fichier est stockée la base de données SQLite
                automatiquement créée au premier affichage du site ? Où le nom
                de ce fichier est-il configuré ? Que se passe-t-il si vous
                supprimez le fichier contenant la base de données ?
                <aside class="correction">
                  La base est dans « database.db », la configuration du nom est
                  dans « blog/__init__.py ». Si le fichier contenant la base
                  de données est supprimé, il est automatiquement recréé à
                  chaque requête
                </aside>
              </li>
              <li>
                Comment l’application sait quel fichier HTML elle doit afficher
                pour une URL donnée ?
                <aside class="correction">
                  L’URL est dans <code>@app.get()</code>, le nom du template
                  est dans <code>render_template()</code>
                </aside>
              </li>
              <li>
                Ces fichiers ne sont pas du HTML pur, mais des
                <em>templates</em> écrits dans un langage proche de HTML,
                permettant entre autres de faire des conditions, des boucles et
                d’afficher des variables. D’après la documentation de Flask,
                comment s’appelle se langage ?
                <aside class="correction">
                  Jinja
                </aside>
              </li>
              <li>
                Comment le HTML sait-il quel fichier CSS utiliser ? Quelle
                fonction est utilisée dans le <em>template</em>
                « _layout.jinja2 » pour déterminer l’URL vers le fichier CSS ?
                <aside class="correction">
                  Le CSS est défini dans
                  <code>blog/templates/_layout.jinja2</code> et son URL est
                  déterminée par <code>url_for()</code>
                </aside>
              </li>
              <li>
                Certaines pages utilisent des formulaires. Quel type de requête
                HTTP est effectué lorsque le formulaire est envoyé par le
                navigateur ? Comment l’application Flask différencie-t-elle les
                requêtes POST des requêtes GET pour ses routes ? Comment
                peut-on récupérer les informations du formulaire dans le code
                Python ?
                <aside class="correction">
                  Les formulaires sont envoyés avec des requêtes POST, on
                  utilise <code>@app.get()</code> et <code>@app.post()</code>
                  pour différencier les GET et POST. Les informations du
                  formulaires sont dans <code>request.form</code>
                </aside>
              </li>
              <li>
                Pour la connexion, on utilise le concept de « session » proposé
                par Flask (et la grande majorité des <em>frameworks</em> web).
                Quelle information est enregistrée dans la session lors de la
                connexion et enlevée lors de la déconnexion ?
                <aside class="correction">
                  On stocke l’ID de la personne connectée
                </aside>
              </li>
              <li>
                La session est également utilisée dans « _layout.jinja2 » pour
                afficher des liens différents selon si l’on est connecté ou
                non. Trouvez dans la <em>Template Designer Documentation</em>
                de Jinja pourquoi on peut utiliser indifféremment
                <code>session.person_id</code>
                et <code>session['person_id']</code> dans Jinja, alors qu’on
                utilise forcément <code>session['person_id']</code> en Python.
                <aside class="correction">
                  D’après la documentation de Jinja : "You can use a dot (.) to
                  access attributes of a variable in addition to the standard
                  Python __getitem__ “subscript” syntax ([])."
                </aside>
              </li>
              <li>
                La variable <code>session</code> est automatiquement passée
                dans tous les <em>templates</em>. Quelles autres variables et
                fonctions sont également passées automatiquement ?
                <aside class="correction">
                  D’après la documentation de Flask : "Inside templates you
                  also have access to the config, request, session and g
                  objects as well as the url_for() and get_flashed_messages()
                  functions."
                </aside>
              </li>
              <li>
                Comment passer d’autres variables dans un <em>template</em>,
                comme par exemple <code>articles</code> pour afficher la liste
                des articles sur la page d’accueil ?
                <aside class="correction">
                  On les passe en comme arguments à <code>render_template</code>
                </aside>
              </li>
            </ol>
            <h4>Corriger les problèmes de sécurité</h4>
            <ol>
              <li>
                Lors de l’ajout d’un article, on ne peut pas définir le titre.
                Nous allons remédier à cela !
                <ul>
                  <li>
                    Dans « blog/templates/add_article.html_», vous ajoutez un
                    label « Titre » contenant un <code>&lt;input name="title" /&gt;</code>.
                  </li>
                  <li>
                    Dans la fonction <code>add_article_post</code> du fichier
                    « blog/__init__.py », vous récupérez le titre du formulaire
                    et vous le mettez dans la requête SQL à la place de
                    « Titre ».
                  </li>
                </ul>
                Vous vérifiez que tout fonctionne correctement. C’est mieux
                comme ça !
                <aside class="correction">
                  <pre>&lt;form method="post"&gt;
  &lt;label&gt;
    Titre
    &lt;input name="title" /&gt;
  &lt;/label&gt;
  &lt;label&gt;
    Contenu de l’article
    &lt;textarea name="content"&gt;&lt;/textarea&gt;
  &lt;/label&gt;
  &lt;input type="submit" /&gt;
&lt;/form&gt;</pre>
                  <pre># Get new article title and content from form
content = request.form["content"]
title = request.form["title"]

# Add article into database
connection = get_connection()
cursor = connection.cursor()
cursor.execute(
    f"INSERT INTO article (title, content) VALUES ('{title}', '{content}')"
)
connection.commit()</pre>
                </aside>
              </li>
              <li>
                Après réflexion, vous vous rendez compte d’un problème de
                sécurité grave. Vous créez un nouvel article en mettant comme
                contenu <code>contenu'), ('hacker', 'hacker</code>. Que se
                passe-t-il alors ? Comment cela est-il possible ?
                <aside class="correction">
                  Deux articles sont créés à la place d’un, parce que la
                  requête SQL devient
                  <pre>INSERT INTO article (title, content) VALUES
('titre', 'contenu'),
('hacker', 'hacker')</pre>
                </aside>
              </li>
              <li>
                Ce problème de sécurité est une injection SQL ! Elle peut
                permettre à un utilisateur malintentionné d’exécuter n’importe
                quel SQL dans la base de données, et donc potentiellement de
                récupérer ou d’effacer l’intégralité des données de la base.
                Vous lisez plus d’informations sur ce sujet dans la
                documentation du module <code>sqlite3</code> de la
                documentation Python.
              </li>
              <li>
                Grâce aux <em>placeholders</em>, il n’y a pas d’injection SQL
                possible avec la route <code>article</code> par exemple.
                Utilisez des <em>placeholders</em> dans la route
                <code>add_article_post</code> à la place de
                la <em>f-string</em>, et vérifiez qu’il n’est plus possible
                d’effectuer une injection SQL.
                <aside class="correction">
                  <pre>cursor.execute(
    "INSERT INTO article (title, content) VALUES (:title, :content)",
    {'title': request.form["title"], 'content': request.form["content"]}
)</pre>
                </aside>
              </li>
              <li>
                Vous vous rendez-compte d’une fonctionnalité très pratique :
                vous pouvez mettre du HTML dans vos articles ! Créez un article
                avec <code>&lt;span style="color: blue">Coucou&lt;/span></code>
                comme contenu. Affichez l’article, et découvrez votre œuvre
                d’art !
              </li>
              <li>
                Cette fonctionnalité est pratique, mais très dangereuse… Créez
                un article avec comme contenu
                <code>&lt;script&gt;alert('hacker')&lt;/script&gt;</code>, puis
                affichez cet article. Que se passe-t-il alors ? Comment cela
                est-il possible ?
                <aside class="correction">
                  Du JavaScript a été injecté dans le HTML, on a donc une boîte
                  de dialogue qui s’ouvre dans le navigateur
                </aside>
              </li>
              <li>
                Ce problème s’appelle du <em>cross-site scripting</em>, souvent
                abrégé <abbr>XSS</abbr> ! Il permet à un utilisateur
                malintentionné de mettre du HTML arbitraire dans une page du
                site, et donc potentiellement du JavaScript malveillant. Vous
                lisez plus d’informations sur ce sujet dans la documentation de
                Flask, ainsi que sur Wikipédia.
              </li>
              <li>
                Par défaut, Flask et Jinja vous protègent des XSS lorsque vous
                rendez des fichiers HTML. Vous vérifiez cela en créant un
                nouvel article avec
                <code>&lt;span style="color: blue"&gt;Coucou&lt;/span&gt;</code>
                comme titre : le HTML est échappé, on obtient du texte normal
                et pas des balises. Vous trouvez alors dans
                « blog/templates/article.html » pourquoi le contenu n’est pas
                échappé, et vous enlevez cette « fonctionnalité » bien trop
                dangereuse. Quelle est la fonctionnalité, et pourquoi ?
                <aside class="correction">
                  On enlève <code>| safe</code> qui n’échappe pas le HTML
                </aside>
              </li>
              <li>
                Le lien pour créer un article n’est affiché que lorsque l’on
                est connecté. On ne peut donc pas aller sur la page de création
                d’un article lorsque l’on n’est pas connecté, à moins que…
                Vous essayez d’aller sur la page
                <a href="http://localhost:5000/article/add">http://localhost:5000/article/add</a>
                alors que vous êtes déconnecté·e. Que se passe-t-il ? Comment
                cela est-il possible ?
                <aside class="correction">
                  Les liens ne sont pas affichés, mais rien dans le code Python
                  n’empêche une personne déconnectée d’accéder à cette URL
                </aside>
              </li>
              <li>
                La gestion des droits d’une application web doit se faire côté
                serveur, route par route. Il n’est pas suffisant de simplement
                cacher les URL aux personnes déconnectées pour leur interdire
                d’y accéder ! Dans <code>add_article</code>, vos décidez donc
                de renvoyer une erreur HTTP 403 (<em>Forbidden</em>) lorsque
                l’utilisateur n’est pas connecté. Vous pouvez vous inspirer de
                <code>article</code> pour savoir comment renvoyer une erreur
                HTTP, et de <code>logout</code> pour vérifier si l’utilisateur
                est connecté. Vous allez sur
                <a href="http://localhost:5000/article/add">http://localhost:5000/article/add</a>
                et l’erreur apparaît !
                <aside class="correction">
                  <pre># Return 403 error if user is not connected
if "person_id" not in session:
    abort(403)</pre>
                </aside>
              </li>
              <li>
                Mais… ce n’est pas suffisant. Vous vous reconnectez, affichez
                <a href="http://localhost:5000/article/add">http://localhost:5000/article/add</a>,
                puis vous vous déconnectez dans un autre onglet. Sur l’onglet affichant
                <a href="http://localhost:5000/article/add">http://localhost:5000/article/add</a>,
                vous créez un nouvel article. Pourquoi cela fonctionne-t-il ?
                Quelqu’un qui ne s’est jamais connecté pourrait-il faire cela ?
                <aside class="correction">
                  Rien dans le code Python n’empêche une personne déconnectée
                  d’envoyer une requête POST, il est possible d’écrire en local
                  une page HTML qui envoie un formulaire sur cette adresse, ou
                  d’utiliser un client HTTP pour envoyer une requête
                </aside>
              </li>
              <li>
                Vous pouvez corriger ce problème de la même manière que pour
                <code>add_article</code>. Quelle fonction doit être corrigée ?
                <aside class="correction">
                  La fonction <code>add_article_post()</code>
                </aside>
              </li>
            </ol>
          </section>
        </section>
      </section>

      <section id="fiches-ressources">
        <h2>Fiches ressources</h2>

        <section id="installation-et-utilisateur-de-l-interpreteur">
          <h3>Installation et utilisation de l’interpréteur Python</h3>

          <h4>Installation</h4>
          <p>
            Python est un langage interprété, c’est-à-dire qu’il a besoin d’un
            logiciel pour lire le code et l’exécuter. Ce logiciel
            s’appelle <strong>un intérpréteur</strong>.
          </p>
          <p>
            Pour exécuter du code Python, la première étape est donc
            d’installer l’interpréteur Python. Il existe plusieurs manières
            pour ce faire, mais la manière recommandée pour ce cours est
            d’installer la version proposée par votre OS. Il existe même une
            chance pour que l’interpréteur Python soit déjà installé sur votre
            système.
          </p>
          <p>
            Que vous soyez sous Linux, macOS ou Windows, la façon est la même :
            ouvrez un terminal et tapez dedans <code>python3</code>.
          </p>
          <ul>
            <li>
              Si l’interpréteur est déjà installé, vous devez obtenir quelque
              chose comme :
              <pre>Python 3.12.2 […] on linux
Type "help", "copyright", "credits" or "license" for more information.
<span class="rouge">&gt;&gt;&gt;</span></pre>

              Dans ce cas, tout est bon ! Vous devez avoir au moins la version
              3.7 de Python, dans le cas contraire mettez à jour votre
              installation.
            </li>
            <li>
              Si l’interpréteur n’est pas installé, une solution doit vous être
              proposée : un message dans le terminal sous macOS ou Linux, ou
              une fenêtre du Microsoft Store sous Windows. Dans tous les cas,
              suivez les étapes de la solution proposée, et l’interpréteur sera
              installé ! Vous pourrez alors le lancer
              avec <code>python3</code>, et vous obtiendrez le texte indiqué
              ci-dessus.
            </li>
          </ul>
          <p>
            Si vous avez le moindre problème pour installer Python, vous pouvez
            trouver des méthodes alternatives d’installation et de la
            documentation sur
            <a href="https://www.python.org/">le site officiel de Python</a>.
          </p>

          <h4>Mode interactif</h4>
          <p>
            En tapant <code>python3</code> dans votre terminal, vous avez lancé
            Python dans un <strong>mode interactif</strong> qui vous permet de
            taper des commandes et de voir directement le résultat.
          </p>
          <p>
            Ce mode d’utilisation est très pratique lorsque l’on veut exécuter
            quelques commandes manuelles simples. Le résultat des commandes
            saisies est affiché automatiquement, ce qui est particulièrement
            pratique pour effectuer des calculs simples. Essayez par vous-même :
            <pre><span class="rouge">&gt;&gt;&gt;</span> 1 + 1
2</pre>
          </p>
          <p>
            Bien sûr, Python n’est pas uniquement capable d’effectuer des
            calculs simples ! Comme dans tout langage, vous pouvez stocker les
            valeurs dans des variables.
            <pre><span class="rouge">&gt;&gt;&gt;</span> number = 1 + 1
<span class="rouge">&gt;&gt;&gt;</span> number
2
<span class="rouge">&gt;&gt;&gt;</span> number * 2
4</pre>
          </p>
          <p>
            Si vous voulez récupérer le résultat de la dernière commande, une variable <code>_</code> (<em>underscore</em>) est automatiquement disponible pour cela.
            <pre><span class="rouge">&gt;&gt;&gt;</span> 1 + 1
2
<span class="rouge">&gt;&gt;&gt;</span> _
2
<span class="rouge">&gt;&gt;&gt;</span> number = _
<span class="rouge">&gt;&gt;&gt;</span> number
2</pre>
          </p>
          <p>
            Outre les nombres entiers, vous pouvez également manipuler des
            nombres à virgule et des chaînes de caractères. Il est également
            possible de mettre des commentaires.
            <pre><span class="rouge">&gt;&gt;&gt;</span> 1 + 1.5  <span class="gris"># integer + float</span>
2.5
<span class="rouge">&gt;&gt;&gt;</span> 'Text'  <span class="gris"># string</span>
'Text'
<span class="rouge">&gt;&gt;&gt;</span> _ + _  <span class="gris"># concatenate 'Text' and 'Text'</span>
'TextText'</pre>
          </p>
          <p>
            Vous n’avez pas besoin de déclarer ses variables ni de gérer la
            mémoire : Python s’occupe de tout. Une variable peut contenir
            n’importe quel type de données au fur et à mesure de l’exécution du
            programme, on dit que
            <strong>Python est un langage typé dynamiquement</strong> (et pas
            un langage typé statiquement, comme C ou Java par exemple). Cela
            dit, le contenu des variables ne peut pas changer de type. Par
            exemple, on ne peut pas additionner un nombre et une chaîne de
            caractères. On dit donc que <strong>Python est un langage fortement
            typé</strong> (et pas faiblement typé, comme JavaScript par
            exemple).
          </p>
          <p>
            Comme l’interpréteur Python est responsable de la gestion de la
            mémoire, on dit qu’il est
            <em><a href="https://en.wikipedia.org/wiki/Memory_safety">memory-safe</a></em>.
            Cela signifie qu’un script écrit en Python est protégé contre
            beaucoup de failles de sécurité basées sur l’accès à la mémoire,
            comme les <em>buffer overflows</em> et les <em>dangling pointers</em>.
          </p>
          <p>
            Si l’on veut afficher une variable dans une chaîne de caractères,
            une méthode possible est d’utiliser les <em>f-strings</em> :
            <pre><span class="rouge">&gt;&gt;&gt;</span> result = 1 + 1
<span class="rouge">&gt;&gt;&gt;</span> f'The number {result} is the result of 1 + 1'
The number 2 is the result of 1 + 1</pre>
          </p>
          <p>
            Les chaînes de caractères sont par défaut sur une ligne, mais il
            est possible de définir des blocs de texte sur plusieurs lignes en
            utilisant <code>&#39&#39&#39</code> (trois guillemets à la suite) :
            <pre><span class="rouge">&gt;&gt;&gt;</span> &#39&#39&#39This is
<span class="rouge">...</span> a long text&#39&#39&#39
'This is<span class="bleu">\n</span>a long text'</pre>
          </p>
          <p>
            Les guillemets simples ou double peuvent être utilisés pour les
            chaînes de caractères, sans aucune différence entre les deux.
            Le <code>f</code> devant les guillemets fonctionne aussi pour les
            blocs de texte.
            <pre><span class="rouge">&gt;&gt;&gt;</span> f&quot;&quot;&quot;This is
<span class="rouge">...</span> a long text with number {result} in it&quot;&quot;&quot;
'This is<span class="bleu">\n</span>a long text with number 2 in it'</pre>
          </p>
          <p>
            <strong>Pour quitter l’interpréteur interactif</strong>,
            tapez la commande <code>quit()</code>.
          </p>
          <p>
            Pour en apprendre plus sur l’interpréteur interactif et les types
            simples, vous pouvez suivre
            <a href="https://docs.python.org/3/tutorial/introduction.html">la partie 3 du tutoriel de la documentation officielle de Python</a>.
          </p>
          <h4>Exécution de scripts</h4>
          <p>
            Si le mode interactif est pratique pour les commandes simples, il
            n’est bien sûr pas adapté lorsque l’on a plus de code à saisir.
            Dans ces cas-là, <strong>on préfère utiliser l’interpréteur pour
            exécuter des scripts écrits dans des fichiers</strong> avec un
            éditeur de code.
          </p>
          <figure class="fichier">
            <figcaption><code>script.py</code></figcaption>
            <pre>number = 2
print(number * 2)</pre>
          </figure>
          <p>
            Vous pouvez exécuter le code en passant le nom de fichier à
            l’interpréteur, dans votre terminal :
            <pre>python3 script.py
4</pre>
          </p>
          <p>
            En mode interactif, Python affiche le résultat de la commande
            effectuée. Ce n’est pas le cas lorsque l’on exécute un script. On
            doit alors utiliser la fonction <code>print()</code> qui affiche
            sur l’écran le résultat du code entre parenthèses.
          </p>
        </section>

        <section id="choix-et-configuration-d-un-editeur">
          <h3>Choix et configuration d’un éditeur</h3>
          <p>
            <strong>Le choix d’un éditeur de code est important pour le développement
            de scripts et d’applications.</strong> Un éditeur est un outil puissant
            lorsqu’il est bien utilisé : il peut vous apporter coloration
            syntaxique, détection d’erreurs, interface de débogage, et bien
            d’autres choses encore.
          </p>
          <p>
            Si vous avez déjà l’habitude d’utiliser un éditeur de code généraliste, il y
            a de grandes chances pour que vous puissiez également l’utiliser pour écrire
            du Python. N’hésitez pas à consulter la documentation de votre
            éditeur pour en apprendre plus sur la manière de l’utiliser pour
            écrire du code Python.
          </p>
          <p>
            Si vous n’avez pas d’éditeur préféré, nous vous conseillons
            d’utiliser <a href="https://code.visualstudio.com/">Visual Studio Code</a> pour
            cette introduction à Python. VS Code est un éditeur généraliste qui
            propose un bon support de Python.
          </p>
          <p>
            Pour commencer, vous pouvez simplement installer VS Code et
            <a href="https://marketplace.visualstudio.com/items?itemName=ms-python.python">l’extension Python</a>,
            la configuration par défaut devrait vous permettre d’avoir entre
            autres la coloration syntaxique, la vérification des erreurs et la
            possibilité de lancer un script Python.
          </p>
          <p>
            Si vous souhaitez en apprendre plus, pour avoir une utilisation plus
            poussé de l’éditeur, vous pouvez suivre
            <a href="https://code.visualstudio.com/docs/python/python-quick-start">le tutoriel Python</a>
            sur le site de VS Code.
          </p>
          <p>
            D’autres éditeurs sont bien sûr disponibles. Parmi les plus
            utilisés, nous noterons par exemple
            <a href="https://www.jetbrains.com/pycharm/">PyCharm</a>,
            <a href="https://www.sublimetext.com/">Sublime Text</a>,
            <a href="https://notepad-plus-plus.org/">Notepad++</a>,
            <a href="https://www.vim.org/">Vim</a> ou
            <a href="https://www.gnu.org/software/emacs/">Emacs</a>.
          </p>
        </section>

        <section id="syntaxe-types-et-instructions">
          <h3>Syntaxe, types et instructions</h3>

          <p>
            Voici un exemple de code Python :
          </p>
          <pre><code>numbers = (1, 2, 3)

<span class="vert">def</span> <span class="jaune">double</span>(number):
    <span class="vert">return</span> number * 2

<span class="vert">for</span> i <span class="vert">in</span> numbers:
    print(double(i))</code></pre>
          <p>
            Avec quelques bases de programmation, et sans entrer dans le
            détail, il est possible de deviner ce que fait ce programme :
          </p>
          <ul>
            <li>On définit une suite de nombres comprenant les nombres 1, 2, 3.</li>
            <li>On définit une fonction qui prend en paramètre un nombre et renvoie ce nombre multiplié par 2.</li>
            <li>Pour chacun des nombres dans la liste de nombres, affiche le double de ce nombre.</li>
          </ul>

          <h4>Syntaxe de base</h4>
          <p>
            <strong>Python est un langage dont les blocs sont déterminés par
            l’indentation</strong>, c’est-à-dire les espaces en début de ligne.
            L’ouverture de blocs se fait par un deux-points. On n’utilise donc
            pas d’accolades pour délimiter les blocs, contrairement à beaucoup
            de langages populaires.
          </p>
          <p>
            Pour l’indentation, on utilise généralement 4 espaces. Par défaut,
            votre éditeur doit faire cela lorsque vous appuyez sur la touche <kbd>Tab</kbd>,
            mais vérifiez bien avant de l’utiliser. Faites surtout attention à
            ne pas mélanger les espaces et les tabulations, qui sont des
            caractères différents !
          </p>
          <p>
            Les lignes de Python ne se terminent pas par un point-virgule, il est
            inutile. Le saut de ligne indique la fin d’une commande. Ne mettez-pas de
            points-virgules, ce n’est pas dans les usages.
          </p>
          <p>
            Il est possible d’ajouter des commentaires avec le croisillon
            <kbd>#</kbd>, la touche du clavier avec le caractère qui ressemble à un
            dièse (♯). Tout ce qui est derrière un croisillon est un commentaire,
            jusqu’au bout de la ligne. Pour faire des commentaires sur plusieurs lignes,
            il est donc nécessaire de mettre un croisillon au début de chaque ligne.
          </p>
          <pre><code><span class="gris"># This is a comment</span>
a = 1 + 2  <span class="gris"># This is a comment too</span>
<span class="gris"># This is</span>
<span class="gris"># a comment on 2 lines</span></code></pre>

          <h4>Nombres</h4>
          <p>
            En Python, des types de base sont disponibles pour représenter les
            données et structures de données communes.
          </p>
          <p>
            <strong>Pour stocker les nombres, on peut utiliser deux types
            principaux : les nombres entiers (<code>int</code>) et les nombres à virgule
            flottante (<code>float</code>).</strong>
          </p>
          <pre><code>a = 12
b = 1.2345
c = a * 3</code></pre>
          <p>
            Les opérations de base utilisent les opérateurs classiques en
            programmation (<code>+</code>, <code>-</code>, <code>*</code>,
            <code>/</code>…).
          </p>
          <p>
            Il n’est pas besoin de définir la taille maximale d’un nombre, ni
            de définir s’il peut être négatif : Python gère automatiquement les
            nombres très grands et les nombres négatifs, sans que l’on ait à
            utiliser des types spécifiques.
          </p>
          <p>
            D’autres types de nombres et d’autres opérateurs moins utilisés
            sont également disponibles.
          </p>

          <h4>Chaînes de caractères</h4>
          <p>
            <strong>Les chaînes de caractères (<code>str</code>) représentent
            du texte.</strong> Le texte est encadré par les guillemets simples
            ou des guillemets doubles.
            <a href="https://fr.wikipedia.org/wiki/Unicode">Unicode</a>
            est supporté, ce qui veut dire que vous pouvez mettre n’importe
            quel caractère dans votre chaîne, y compris des émojis.
          </p>
          <pre><code>message = <span class="rouge">"Salut !"</span>
answer = <span class="rouge">'Coucou 😄 ça va ?'</span></code></pre>
          <p>
            Les <em>f-strings</em> sont des chaînes de caractères avec la
            lettre <code>f</code> devant les guillemets. Elles permettent de
            pouvoir insérer des variables de n’importe quel type (et même du
            code plus complexe !) directement dans des chaînes de caractères.
          </p>
          <pre><code>name = <span class="rouge">"Victor"</span>
question = <span class="rouge">f"Comment ça va <span class="bleu">{name}</span> ?"</span>
print(<span class="rouge">f"1 + 1 = <span class="bleu">{1 + 1}</span>"</span>)</code></pre>

          <h4>Conditions et booléens</h4>
          <p>
            <strong>Il est possible d’effectuer des tests de conditions grâce aux
            mots-clés <code>if</code>, <code>elif</code> et <code>else</code>.</strong>
          </p>
          <pre><code>a = 2

<span class="vert">if</span> a == 0:
    print(<span class="rouge">"zero"</span>)
<span class="vert">elif</span> a == 1:
    print(<span class="rouge">"one"</span>)
<span class="vert">else</span>:
    print(<span class="rouge">"two or more"</span>)</code></pre>
          <p>
            <code>if</code> permet de tester une condition. Son bloc est
            exécuté si la condition est vraie. <code>elif</code> permet
            également de tester une condition, son bloc est exécuté si toutes
            les conditions du <code>if</code> et des <code>elif</code> précédents sont
            fausses, et que sa propre condition est vraie. Le bloc <code>else</code> est
            effectué si toutes les conditions précédentes sont fausses.
          </p>
          <p>
            L’opérateur <code>==</code> permet de tester une égalité. Il est
            également possible de tester une inégalité (avec
            <code>>=</code> ou <code>&lt;</code> par exemple) ou une différence
            (avec <code>!=</code>). On peut enchaîner plusieurs de ces
            opérateurs à la suite pour effectuer plusieurs tests en même
            temps.
          </p>
          <p>
            Tous ces opérateurs renvoient « vrai » ou « faux ». Ce sont les
            booléens (<code>bool</code>), que l’on note <code>True</code> et
            <code>False</code> en Python. Les opérateurs booléens sont notés
            <code>and</code>, <code>or</code> et <code>not</code>, en toutes
            lettres.
          </p>
          <pre><code><span class="vert">if</span> a == 0 <span class="vert">or</span> a == 1:
    print(<span class="rouge">"zero or one"</span>)
<span class="vert">elif</span> 2 &lt;= a &lt;= 10:
    print(<span class="rouge">"between two and ten"</span>)
<span class="vert">else</span>:
    print(<span class="rouge">"eleven or more"</span>)</code></pre>

          <h4>Boucles</h4>
          <p>
            <strong>Les mots réservés <code>for</code> et <code>while</code>
            permettent de construire des boucles.</strong>
          </p>
          <p>
            La boucle <code>for</code> prend les éléments d’une suite
            d’éléments un par un, les met dans une variable, et exécute son
            bloc avec cette variable. Elle s’arrête lorsqu’il n’y a plu
            d’éléments dans la suite.
          </p>
          <pre><code><span class="vert">for</span> a <span class="vert">in</span> (1, 2, 3):
    <span class="gris"># Print 1, then 2, then 3</span>
    print(a)</code></pre>
          <p>
            Dans d’autres langages, cette boucle s’appelle parfois une boucle
            <code>foreach</code>. Si l’on veut itérer sur une suite d’indices plutôt que
            sur des éléments dans une suite, on peut utiliser la fonction
            <code>range(x)</code> qui renvoie une suite de nombres entre 0
            inclus et <code>x</code> exclu.
          </p>
          <pre><code><span class="vert">for</span> a <span class="vert">in</span> range(3):
    <span class="gris"># Print 0, then 1, then 2</span>
    print(a)</code></pre>
          <p>
            La boucle <code>while</code> exécute son bloc tant que sa
            condition est vraie.
          </p>
          <pre><code>a = 3
<span class="vert">while</span> a <span class="vert">&gt;</span> 0:
    <span class="gris"># Print 3, then 2, then 1</span>
    print(a)
    a = a - 1  <span class="gris"># Decrement a</span></code></pre>
          <p>
            Les variables définies dans une boucle sont accessibles après
            cette boucle.
          </p>
          <pre><code><span class="vert">for</span> a <span class="vert">in</span> (1, 2, 3):
    <span class="gris"># Print 1, then 2, then 3</span>
    print(a)

<span class="gris"># a == 3 at the end of the loop</span>

<span class="vert">while</span> a > 0:
    <span class="gris"># Print 3, then 2, then 1</span>
    print(a)
    a = a - 1</code></pre>
          <p>
            On peut interrompre une boucle sans aller jusqu’au bout de son
            exécution grâce à la commande <code>break</code>. Il est
            également possible de passer à l’itération suivante sans aller
            jusqu’au bout du bloc de la boucle grâce à
            <code>continue</code>.
          </p>
          <p>
            Il est possible d’ajouter un bloc <code>else</code> à la fin
            d’une boucle. Elle sera exécutée si la boucle est allée jusqu’au
            bout, sans <code>break</code>.
          </p>
          <pre><code><span class="gris"># Find a positive number divisible by 4</span>
numbers = (10, 13, -4, 7, 12, 14)
<span class="vert">for</span> number <span class="vert">in</span> numbers:
    <span class="vert">if</span> number < 0:
        print(<span class="rouge">f"<span class="bleu">{number}</span> est un nombre négatif"</span>)
        <span class="vert">continue</span>  <span class="gris"># Go no next number</span>

    <span class="vert">if</span> number % 4 == 0:
        print(<span class="rouge">f"<span class="bleu">{number}</span> est divisible par 4 !"</span>)
        <span class="vert">break</span>  <span class="gris"># Stop the loop</span>
    <span class="vert">else:</span>
        print(<span class="rouge">f"<span class="bleu">{number}</span> n’est pas divisible par 4"</span>)
<span class="vert">else</span>:
    print(<span class="rouge">"Aucun nombre n’est divisible par 4"</span>)</code></pre>

          <h4>Séquences</h4>
          <p>
            <strong>En Python, le terme de « séquence » regroupe tous les types qui
            permettent de stocker et accéder à des éléments par rapport à leur
            indice.</strong> Par exemple, les chaînes de caractères sont des séquences.
          </p>
          <pre><code>name = <span class="rouge">"Victor"</span>
print(name[2])  <span class="gris"># Print "c", letter at index 2 (starting from 0)</span></code></pre>
          <p>
            Les séquences ont également une longueur.
          </p>
          <pre><code>name = <span class="rouge">"Victor"</span>
print(len(name))  <span class="gris"># Print "6" because there are 6 letters</span></code></pre>
          <p>
            Toutes les séquences sont itérables, c’est-à-dire qu’on peut
            prendre leurs éléments un à un, par exemple dans une boucle
            <code>for</code>.
          </p>
          <pre><code><span class="vert">for</span> letter <span class="vert">in</span> <span class="rouge">"abc"</span>:
    <span class="gris"># Print "a", then "b", then "c"</span>
    print(letter)</code></pre>
          <p>
            (L’inverse n’est pas vrai, certains itérables ne sont pas des
            séquences).
          </p>
          <p>
            Deux types très répandus sont également des séquences : les listes
            (<code>list</code>) et les n-uplets (<code>tuple</code>). Ces deux
            types permettent de stocker une suite d’éléments :
          </p>
          <pre><code>a_list = [1, 2, 4]
a_tuple = (1, 2, 4)
print(a_list[2])  <span class="gris"># Print 4</span>
print(len(a_tuple))  <span class="gris"># Print 3</span></code></pre>
          <p>
            Il existe une différence entre ces deux types : <strong>les listes sont
            modifiables, alors que les n-uplets ne le sont pas</strong>.
          </p>
          <pre><code>a_list = [<span class="rouge">"a"</span>, <span class="rouge">"b"</span>, <span class="rouge">"e"</span>]
a_list[2] = <span class="rouge">"c"</span>  <span class="gris"># Replace "e" by "c"</span>
print(a_list)  <span class="gris"># Print ["a", "b", "c"]</span>

a_tuple = (<span class="rouge">"a"</span>, <span class="rouge">"b"</span>, <span class="rouge">"e"</span>)
a_tuple[2] = <span class="rouge">"c"</span>  <span class="gris"># Error!</span></code></pre>
          <p>
            On dit que <strong>les listes sont mutables</strong>, et
            <strong>les n-uplets immuables</strong>. Les chaînes de caractères
            sont également immuables
          </p>
          <p>
            Comme les listes sont mutables, il existe plusieurs façons communes
            de les modifier. On peut par exemple ajouter un élément, enlever un
            élément, ranger et vider une liste.
          </p>
          <pre><code>a_list = [10, 8, 2, 38]
a_list.append(33)  <span class="gris"># a_list == [10, 8, 2, 38, 33]</span>
a_list.pop(1)  <span class="gris"># a_list == [10, 2, 38, 33]</span>
a_list.sort()  <span class="gris"># a_list == [2, 10, 33, 38]</span>
a_list.clear()  <span class="gris"># a_list == []</code></pre></span>
          <p>
            De nombreuses autres fonctionnalités sont disponibles sur
            <a href="https://docs.python.org/3/library/stdtypes.html#typesseq-common">toutes les séquences</a>
            ainsi que sur
            <a href="https://docs.python.org/3/library/stdtypes.html#typesseq-mutable">les séquences mutables</a>.
          </p>

          <h4>Dictionnaires</h4>
          <p>
            <strong>Les dictionnaires (<code>dict</code>) permettent d’associer
            des valeurs à des clés.</strong>
          </p>
          <p>
            Les dictionnaires sont les objets les plus utilisés dans le
            fonctionnement interne de Python. Ils sont très compacts et très
            rapides. Ils sont également mutables.
          </p>
          <pre><code>fruit_color = {<span class="rouge">"banana"</span>: <span class="rouge">"yellow"</span>, <span class="rouge">"kiwi"</span>: <span class="rouge">"green"</span>}
fruit_color[<span class="rouge">"mango"</span>] = <span class="rouge">"orange"</span>  <span class="gris"># Add key "mango" with value "orange"</span>
print(fruit_color[<span class="rouge">"mango"</span>])  <span class="gris"># Print "orange"</span>
print(fruit_color)  <span class="gris"># Print the whole dictionary</span></code></pre>
          <p>
            Les dictionnaires sont des itérables : itérer sur un dictionnaire
            retourne les clés, qui sont ordonnées. Par contre, les
            dictionnaires ne sont pas des séquences : on accède aux valeurs par
            une clé, non par un indice.
          </p>
          <p>
            De nombreuses autres fonctionnalités sont disponibles sur
            <a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict">les dictionnaires</a>.
          </p>
        </section>

        <section id="fonctions">
          <h3>Fonctions</h3>
          <p>
            <strong>En Python, il est possible de définir des fonctions qui
            prennent en paramètres des valeurs, qui exécutent du code et qui
            renvoient potentiellement une nouvelle valeur.</strong>
          </p>
          <pre><code><span class="vert">def</span> divide(numerator, denominator):
    <span class="rouge">"""Return numerator divided by denominator."""</span>
    <span class="vert">return</span> numerator / denominator

print(divide(10, 5))  <span class="gris"># Print "2.0"</span></code></pre>
          <p>
            La chaîne de caractères au tout début de la fonction s’appelle une
            <em>docstring</em>. C’est de la documentation à destination des
            personnes qui utilisent votre code, sans forcément lire votre code.
            On utilise toujours trois paires de guillemets pour cette
            documentation, même lorsqu’elle ne fait qu’une ligne. Vous pouvez
            par exemple voir la documentation avec <code>help</code>.
          </p>
          <pre><code>help(divide)
help(list)
help(3.14)</code></pre>
          <p>
            Lorsque l’on appelle une fonction, il est possible de nommer les
            paramètres afin de pouvoir les passer dans n’importe quel ordre.
          </p>
          <pre><code>print(divide(denominator=3, numerator=6))  <span class="gris"># Print "2.0"</span></code></pre>
          <p>
            Il est également possible de définir des valeurs par défaut qui
            seront utilisées si aucun argument n’est passé pour ces paramètres.
          </p>
          <pre><code><span class="vert">def</span> divide(numerator, denominator=2):
    <span class="rouge">"""Return numerator divided by denominator (2 by default)."""</span>
    <span class="vert">return</span> numerator / denominator

print(divide(10))  <span class="gris"># Print "5.0"</span></code></pre>
          <p>
            Les fonctions en Python proposent
            <a href="https://docs.python.org/3/tutorial/controlflow.html#defining-functions">un grand nombre de fonctionnalités additionnelles</a>.
          </p>
        </section>

        <section id="programmation-objet">
          <h3>Programmation orientée objet</h3>
          <p>
            Python est un langage particulièrement adapté à la programmation
            orientée objet. <strong>Tout ce que l’on manipule (ou presque) est
            un objet</strong> : les entiers, les listes, les dictionnaires, les
            fonctions, etc.
          </p>
          <p>
            Au-delà des types proposés par défaut, <strong>il est possible de
            créer ses propres types grâce aux classes</strong>.
          </p>
          <pre><code><span class="vert">class</span> <span class="jaune">Animal</span>:
    <span class="rouge">"""Representation of an animal."""</span>

    <span class="vert">def</span> <span class="jaune">__init__</span>(self, name):
        <span class="rouge">"""Initialize a new animal."""</span>
        self.name = name

    <span class="vert">def</span> <span class="jaune">say_hello</span>(self):
        <span class="rouge">"""Print a little presentation of the animal."""</span>
        print(<span class="rouge">f"Hello! My name is <span class="bleu">{self.name}</span>."</span>)

tweety = Animal(<span class="rouge">"Tweety"</span>)  <span class="gris"># Create "tweety", an instance of "Animal"</span>
tweety.say_hello()  <span class="gris"># Print "Hello! My name is Tweety"</span>
print(tweety.name)  <span class="gris"># Print "Tweety"</span></code></pre>
          <p>
            Une classe représente un type standard d’objet. À partir de ce
            type, on peut créer différents objets, qui auront généralement la
            même structure et le même fonctionnement (les animaux ont un nom et
            peuvent se présenter), mais pas forcément les mêmes informations
            (chaque animal aura un nom différent). <strong>Les objets créés à
            partir d’un type sont appelés des instances</strong>, ils sont
            créés en « appelant » la classe, en mettant des parenthèses
            derrière (<code>Animal("Tweety")</code>).
          </p>
          <p>
            Les classes possèdent deux types d’informations qui
            leur sont propres : les attributs et les méthodes.
            <ul>
              <li>
                Les attributs sont comme des variables rattachées à une
                instance. Ici, <code>name</code> est un attribut de chaque
                animal.
              </li>
              <li>
                Les méthodes sont comme des fonctions rattachées à une
                instance. Ici, <code>say_hello</code> est une méthode.
              </li>
            </ul>
          </p>
          <p>
            Les méthodes prennent un paramètre par défaut, que l’on
            nomme toujours <code>self</code>. Ce paramètre correspond à
            l’instance que l’on est en train de manipuler. Par exemple, lorsque
            l’on appelle <code>tweety.say_hello()</code>, on appelle la méthode
            <code>say_hello</code> avec comme premier paramètre
            <code>self</code> qui vaut <code>tweety</code>.
            (<code>self</code> correspond à <code>this</code> dans d’autres
            langages.)
          </p>
          <p>
            La méthode <code>__init__</code> est appelée juste après la
            création d’une instance. Les paramètres passés à
            <code>__init__</code> sont l’instance, puis tous les paramètres
            passés entre les parenthèses. Ainsi,
            <code>tweety = Animal("Tweety")</code> crée une instance d’animal,
            et appelle <code>__init__</code> avec comme arguments l’instance
            créée (<code>self</code>) et la chaîne de caractères Tweety
            (<code>name</code>).
          </p>
          <p>
            Dans notre cas, <code>__init__</code> enregistre le nom passé en
            paramètre comme attribut de l’instance : <code>self.name = name</code>.
            Cela permettra d’accéder au nom d’un animal en ajoutant
            <code>.name</code> derrière notre instance.
          </p>
          <p>
            Comme dans beaucoup de langages orientés objet, <strong>il est
            possible de faire de l’héritage de classes</strong>.
          </p>
          <pre><code><span class="vert">class</span> <span class="jaune">Dog(Animal)</span>:
    <span class="rouge">"""Representation of an dog."""</span>
    kind = <span class="rouge">"canine"</span>

    <span class="vert">def</span> <span class="jaune">say_hello</span>(self):
    <span class="rouge">"""Print a little presentation of the dog."""</span>
        super().say_hello()  # Call Animal.say_hello
        print(<span class="rouge">"I can bark: woof woof"</span>)

pluto = Dog(<span class="rouge">"Pluto"</span>)  <span class="gris"># Create "pluto", an instance of "Dog"</span>
pluto.say_hello()  <span class="gris"># Print "Hello! …" then "I can bark…"</span>
print(pluto.kind)  <span class="gris"># Print "canine"</span></code></pre>
          <p>
            Ici, <code>Dog</code> est une classe qui hérite de <code>Animal</code>.
            Cela signifie que toute instance de <code>Dog</code> sera également
            une instance de <code>Animal</code>, et se comportera donc par
            défaut comme un <code>Animal</code>. Ici, Pluto est un chien, et
            c’est aussi un animal (ce qui semble plutôt normal).
          </p>
          <p>
            Généralement, lorsque l’on crée une classe enfant d’une autre
            classe, on veut réutiliser une partie de ce que la classe parente
            fait. Par exemple, <code>__init__</code> n’est pas redéfini. C’est
            à dire que lorsque l’on appelle <code>Dog("Pluto")</code>, on
            crée une instance de <code>Dog</code>, puis on passe cette instance
            à <code>Animal.__init__</code>. Ce n’est pas la peine de récrire ce
            code, il sera appelé tout seul !
          </p>
          <p>
            Dans des cas plus compliqués, on veut appeler la méthode parente,
            mais on veut faire d’autres choses légèrement différentes. Dans
            notre cas, les chiens disent la même phrase que tous les animaux
            (<em>Hello! My name is…</em>), mais ils doivent également dire
            qu’ils aboient (<em>I can bark…</em>).
          </p>
          <p>
            Pour faire cela, on surcharge la méthode <code>say_hello</code> :
            on redéfinit cette méthode dans <code>Dog</code>. Mais à la place
            de recopier <code>print("Hello!…")</code>, on utilise
            <code>super</code> pour appeler la méthode de la classe parente.
            Ainsi, on peut avoir un fonctionnement légèrement différent sans
            tout avoir à récrire.
          </p>
          <p>
            Cet exemple propose également une fonctionnalité souvent utilisée
            sur les classes : les attributs de classes. Ici, <code>kind</code>
            est défini au niveau de la classe, pas dans <code>__init__</code>
            lors de l’instanciation. C’est normal : tous les chiens sont de la
            même espèce (<code>kind</code> est un attribut de classe), mais
            chacun à son nom propre (<code>name</code> est un attribut
            d’instance).
          </p>
          <p>
            Beaucoup d’autres choses peuvent être faites
            <a href="https://docs.python.org/3/tutorial/classes.html">avec les classes en Python</a>.
          </p>
        </section>

        <section id="modules-et-imports">
          <h3>Modules et imports</h3>
          <p>
            Lorsque les applications comportent une grande quantité de code, il
            devient vite indispensable de répartir ce code dans différents
            dossiers et fichiers. <strong>On utilise alors des imports pour
            utiliser le code d’un fichier dans un autre fichier.</strong>
          </p>

          <h4>Modules et paquets</h4>
          <p>
            <strong>Les modules contiennent du code qui peut être importé afin
            d’être utilisé dans d’autres fichiers.</strong>
          </p>
          <p>
            Les modules sont généralement stockés sous forme de fichiers, qui
            contiennent du code utilisable par d’autres applications. Afin
            d’avoir une organisation hiérarchique des modules, on peut les
            regrouper dans des modules spéciaux appelés paquets. Les paquets se
            comportent comme des dossiers dans un système de fichiers : ils
            peuvent contenir des fichiers et des dossiers, qui eux-mêmes
            peuvent contenir fichiers et dossiers.
          </p>
          <p>
            Lorsqu’il est importé, un module stocké sous forme de fichier est
            un objet dont les attributs sont les éléments définis à la racine
            du fichier : classes, fonctions, variables, mais également imports.
          </p>
          <p>
            Lorsqu’un paquet stocké sous forme de fichier est importé, ses
            attributs sont alors les éléments définis à la racine du fichier
            <code>__init__.py</code> qu’il contient, s’il existe.
          </p>

          <h4>Imports absolus</h4>
          <p>
            Les imports absolus permettent d’avoir accès :
          </p>
          <ul>
            <li>
              aux modules de la bibliothèque standard, fournie avec Python,
            </li>
            <li>
              aux modules tiers, en particulier installés avec <code>pip</code>,
            </li>
            <li>
              aux modules situés dans le dossier actuel du terminal (rarement
              utilisé, sauf pour faire des tests ou lors du développement d’une
              bibliothèque).
            </li>
          </ul>
          <p>
            Pour réaliser un import absolu, on utilise l’une des syntaxes
            suivantes :
          </p>
          <pre><code><span class="gris"># "random" is a module that contains the "randint" function</span>
<span class="vert">import</span> random
print(random.randint(1, 6))

<span class="gris"># we can import only the function, not the whole module</span>
<span class="vert">from</span> random <span class="vert">import</span> randint
print(randint(1, 6))

<span class="gris"># "urllib" is a package that contains the "request" module</span>
<span class="gris"># "request" contains the "urlopen" function</span>
<span class="vert">import</span> urllib.request
urllib.request.urlopen("https://example.com/")

<span class="gris"># or</span>
<span class="vert">from</span> urllib <span class="vert">import</span> request
request.urlopen("https://example.com/")

<span class="gris"># or</span>
<span class="vert">from</span> urllib.request <span class="vert">import</span> urlopen
urlopen("https://example.com/")</code></pre>

          <h4>Imports relatifs</h4>
          <p>
            Les imports relatifs sont utilisés dans des paquets, pour importer
            d’autres modules au sein du même paquet. On ne les utilise donc pas
            dans les scripts exécutés par l’interpréteur.
          </p>
          <p>
            Pour les imports relatifs, on utilise devant le nom du module :
          </p>
          <ul>
            <li><code>.</code> (un point) pour importer un fichier dans le dossier actuel,</li>
            <li><code>..</code> (deux points) pour importer un fichier dans le dossier parent,</li>
            <li><code>...</code> (trois points) pour importer un fichier dans le dossier parent du dossier parent,</li>
            <li>etc.</li>
          </ul>
          <p>
            Voici un exemple de bibliothèque :
          </p>
          <pre>paint
├── __init__.py
├── draw.py
└── colors
    ├── __init__.py
    ├── blue.py
    └── red.py</pre>
          <figure class="fichier">
            <figcaption><code>paint/__init__.py</code></figcaption>
            <pre><code><span class="gris"># Import draw_circle function from paint/draw.py so that users
# can use paint.draw_circle instead of paint.draw.draw_circle</span>
<span class="vert">from</span> .draw <span class="vert">import</span> draw_circle</code></pre>
          </figure>
          <figure class="fichier">
            <figcaption><code>paint/draw.py</code></figcaption>
            <pre><code><span class="vert">def</span> draw_circle(x, y, r):
    <span class="vert">pass</span>  <span class="gris"># draw_circle code</span></code></pre>
          </figure>
          <figure class="fichier">
            <figcaption><code>paint/colors/__init__.py</code></figcaption>
            <pre><code><span class="vert">def</span> set_color(color):
    <span class="vert">pass</span>  <span class="gris"># set_color code</span></code></pre>
          </figure>
          <figure class="fichier">
            <figcaption><code>paint/colors/blue.py</code></figcaption>
            <pre><code><span class="gris"># Import set_color from paint/color/__init__.py</span>
<span class="vert">from</span> . <span class="vert">import</span> set_color

<span class="gris"># Import draw_circle from paint/draw.py</span>
<span class="vert">from</span> ..draw <span class="vert">import</span> draw_circle

<span class="vert">def</span> set_blue_color():
    set_color(<span class="rouge">"blue"</span>)

<span class="vert">def</span> draw_blue_circle(x, y, r):
    set_blue_color()
    draw_circle(x, y, r)</code></pre>
          </figure>
          <figure class="fichier">
            <figcaption><code>paint/colors/red.py</code></figcaption>
            <pre><code><span class="gris"># Import set_color from paint/color/__init__.py</span>
<span class="vert">from</span> . <span class="vert">import</span> set_color

<span class="gris"># Import draw_circle from paint/draw.py</span>
<span class="vert">from</span> ..draw <span class="vert">import</span> draw_circle

<span class="vert">def</span> set_red_color():
    set_color(<span class="rouge">"red"</span>)

<span class="vert">def</span> draw_red_circle(x, y, r):
    set_red_color()
    draw_circle(x, y, r)</code></pre>
          </figure>
          <p>
            On pourrait alors utiliser cette bibliothèque ainsi :
          </p>
          <figure class="fichier">
            <figcaption><code>app.py</code></figcaption>
            <pre><code><span class="gris"># Import paint/draw.py module to use draw_circle</span>
<span class="vert">import</span> paint.draw
paint.draw.draw_circle(2, 4, 5)

<span class="gris"># Shorter solution as draw_circle is imported in paint/__init__.py</span>
<span class="vert">import</span> paint
paint.draw_circle(2, 4, 5)

<span class="gris"># Import draw_blue_circle from paint/colors/blue.py</span>
<span class="vert">from</span> paint.colors.blue <span class="vert">import</span> draw_blue_circle
draw_blue_circle(3, 4, 5)</code></pre>
          </figure>
        </section>

        <section id="bibliotheque-standard">
          <h3>Bibliothèque standard</h3>
          <p>
            <strong>La bibliothèque standard de Python est un ensemble de modules
            fournis avec l’interpréteur.</strong> Python est connu pour être
            fourni « piles incluses », c’est-à-dire avec une bibliothèque
            standard très importante qui apporte de nombreuses fonctionnalités
            sans avoir besoin de modules externes.
          </p>
          <p>
            Python intègre des modules très variés, dont les fonctions
            mathématiques avancées, un support des protocoles réseaux les
            plus répandus, les dates, la lecture et l’écriture de
            fichiers…
          </p>
          <p>
            L’ensemble de la bibliothèque standard est disponible dans
            <a href="https://docs.python.org/3/library/index.html">la documentation</a>.
            Nous ne pouvons bien sûr pas couvrir l’intégralité de ces modules,
            mais nous en détaillerons 3 spécifiques pour comprendre l’intérêt
            de cette large gamme d’outils. À chaque fois, nous donnerons un
            petit script pour comprendre les fonctionnalités principales.
            Toutes les fonctionnalités supplémentaires sont bien sûr à
            découvrir dans la documentation.
          </p>

          <h4>Chemins de système de fichiers orientés objet — <code>pathlib</code></h4>
          <p>
            <strong>La lecture et l’écriture de fichiers textes sont des
            fonctionnalités classiques des langages de programmation.</strong> Python
            fournit une interface bas-niveau pour cela (avec <code>open</code>), mais ce
            fonctionnement n’est pas très pratique ni très moderne.
          </p>
          <p>
            C’est pourquoi Python propose le module
            <a href="https://docs.python.org/3/library/pathlib.html"><code>pathlib</code></a>.
            <code>pathlib</code> offre une interface puissante, orientée objet,
            permettant de réaliser les opérations de base sur un système de
            fichiers : création et suppression de dossiers et de fichiers,
            écriture de texte et de binaire dans les fichiers, listes de
            contenus de dossiers, etc.
          </p>
          <pre><code><span class="vert">from</span> pathlib <span class="vert">import</span> Path

<span class="gris"># Create folder and file</span>
current_folder = Path()  <span class="gris"># Path object to current folder (called ".")</span>
new_folder = current_folder / <span class="rouge">"test"</span>  <span class="gris"># Folder called "test" in "."</span>
new_folder.mkdir()  <span class="gris"># Create "./test" folder</span>
new_file = new_folder / <span class="rouge">"texte.txt"</span>  <span class="gris"># File called "texte.py" in "./test"</span>
new_file.write_text(<span class="rouge">"Salut"</span>)  <span class="gris"># Write "Salut" in "./test/texte.txt"</span>
print(new_file.read_text())  <span class="gris"># Print "Salut"</span>

<span class="gris"># List content of "./test" (only "./test/texte.txt")</span>
<span class="vert">for</span> file <span class="vert">in</span> new_folder.iterdir():
    print(file)

<span class="gris"># Clean everything</span>
new_file.unlink()  <span class="gris"># Delete "./test/texte.txt" file</span>
new_folder.rmdir()  <span class="gris"># Delete empty "./test" folder</span></code></pre>

          <h4>Génération de nombres pseudo-aléatoires — <code>random</code></h4>
          <p>
            <strong>Dans de nombreux programmes, il est nécessaire de générer
            des nombres aléatoires.</strong> Que l’on veuille simuler le
            lancement d’un dé à six faces, choisir au hasard une personne dans
            une liste d’utilisateurs ou mélanger une pile de cartes,
            <code>random</code> est le module adapté pour cela.
          </p>
          <pre><code><span class="vert">import</span> random

<span class="gris"># Print a number between 1 and 6 (like a dice)</span>
print(random.randint(1, 6))

<span class="gris"># Print a random card suit</span>
suits = (<span class="rouge">"♠"</span>, <span class="rouge">"♥"</span>, <span class="rouge">"♦"</span>, <span class="rouge">"♣"</span>)
print(random.choice(suits))

<span class="gris"><span class="gris"># Shuffle a list of numbers</span></span>
numbers = list(range(10))
random.shuffle(numbers)
print(numbers)</code></pre>

          <h4>Fonctions mathématiques — <code>math</code></h4>
          <p>
            <strong>S’il est possible d’utiliser les opérateurs de base sans
            avoir recours à un module, Python est cependant vite limité dès que
            l’on veut faire des opérations mathématiques plus complexes.</strong>
            Heureusement, le module <code>math</code> contient de quoi aller un
            peu plus loin que de simples additions et multiplications :
            trigonométrie, valeurs absolues, factorielles, PGCD et racines
            carrées sont à votre disposition !
          </p>
          <p>
            Le module <code>math</code> est adapté pour des mathématiques de niveau
            collège, mais ce n’est bien sûr pas pour des utilisations universitaires ou
            de recherche ! Pour cela, des modules tiers comme <code>numpy</code> ou <code>pandas</code> sauront
            répondre aux utilisations les plus avancées.
          </p>
          <pre><code><span class="vert">import</span> math

<span class="gris"># A little bit of trigonometry</span>
angle = math.radians(60)  <span class="gris"># Convert 60 degrees in radians</span>
print(math.cos(angle))  <span class="gris"># That’s 0.5!</span>

<span class="gris"># A little bit of geometry</span>
radius = 3
circle_area = math.pi * math.pow(radius, 2)
print(circle_area)

<span class="gris"># A little bit of arithmetic</span>
greatest_common_divisor = math.gcd(20, 30, 100)
print(greatest_common_divisor)  <span class="gris"># That’s 10!</span></code></pre>
        </section>

        <section id="environnements-virtuels">
          <h3>Environnements virtuels</h3>
          <p>
            Lorsque l’on veut développer et utiliser des applications ou des
            bibliothèques, on veut pouvoir installer des programmes utilisant
            des versions précises de Python et des modules externes.
          </p>
          <p>
            Par défaut, l’installation de ces paquets se fait au niveau du
            système. Python permet également à chaque personne d’installer des
            modules uniquement pour elle. Cependant, ces solutions ne
            permettent pas d’avoir des versions concurrentes d’un même module,
            et elles mettent au même endroit des paquets utilisés par
            différents projets.
          </p>
          <p>
            <strong>Les environnements virtuels permettent de créer des
            sous-systèmes indépendants, avec leur interpréteur et leurs modules
            accessibles uniquement depuis l’environnement.</strong> C’est une
            solution pratique pour regrouper dans un dossier tous les modules
            installés spécifiquement pour un projet.
          </p>
          <ul>
            <li>
              Toutes les informations concernant l’environnement virtuel sont
              dans le dossier.
            </li>
            <li>
              Les modules installés dans l’environnement ne sont pas
              accessibles de l’extérieur.
            </li>
            <li>
              Les environnements virtuels sont dépendants du système. On ne les
              versionne pas, on ne les partage pas.
            </li>
          </ul>
          <p>
            Python propose le module <code>venv</code> pour créer des
            environnements virtuels. Ce module est dans la bibliothèque
            standard.
          </p>
          <p>
            Une fois l’environnement créé, il est nécessaire de l’activer.
            Après activation, la commande <code>python3</code> pointera vers
            votre environnement virtuel, et non plus vers la version installée
            sur votre système.
          </p>
          <p>
            Vous pourrez alors installer un module tiers grâce à la commande
            <code>pip install nom_du_projet</code>. Les modules sont
            automatiquement téléchargés depuis <a href="https://pypi.org/">PyPI</a>.
          </p>
          <p>
            Il existe également de nombreux outils externes permettant
            d’utiliser les environnements virtuels, comme Pipenv ou Poetry. Il
            n’est pas nécessaire d’utiliser de tels outils pour cette
            formation.
          </p>
          <figure class="console">
            <figcaption>Exemple sous macOS/Linux</figcaption>
            <pre><code><span class="vert">alice@laptop</span>:<span class="bleu">~/Project</span>$ python3 -m venv venv
<span class="vert">alice@laptop</span>:<span class="bleu">~/Project</span>$ source venv/bin/activate
(venv) <span class="vert">alice@laptop</span>:<span class="bleu">~/Project</span>$ which python3
…/venv/bin/python3
(venv) <span class="vert">alice@laptop</span>:<span class="bleu">~/Project</span>$ pip install …
(venv) <span class="vert">alice@laptop</span>:<span class="bleu">~/Project</span>$ deactivate
<span class="vert">alice@laptop</span>:<span class="bleu">~/Project</span>$ </code></pre>
          </figure>
          <figure class="console">
            <figcaption>Exemple sous Windows</figcaption>
            <pre><code><span class="bleu">C:\Users\Alice\Project</span><span class="vert">></span>python3 -m venv venv
<span class="bleu">C:\Users\Alice\Project</span><span class="vert">></span>venv\Scripts\activate
(venv) <span class="bleu">C:\Users\Alice\Project</span><span class="vert">></span>where python3
…\venv\bin\python3
(venv) <span class="bleu">C:\Users\Alice\Project</span><span class="vert">></span>pip install …
(venv) <span class="bleu">C:\Users\Alice\Project</span><span class="vert">></span>deactivate
<span class="bleu">C:\Users\Alice\Project</span><span class="vert">></span></code></pre>
          </figure>
          <p>
            Un <a href="https://packaging.python.org/en/latest/guides/installing-using-pip-and-virtual-environments/#creating-a-virtual-environment">guide de création et d’utilisation d’environnements virtuels</a>
            est à votre disposition si vous souhaitez en apprendre
            plus sur l’utilisation des environnements virtuels.
          </p>
        </section>

        <section id="flask">
          <h3>Flask</h3>
          <p>
            <strong>Flask est, avec Django, l’un des deux <em>frameworks</em> web
            les plus populaires de l’écosystème Python.</strong>
          </p>
          <p>
            Flask offre principalement :
          </p>
          <ul>
            <li>
              un serveur HTTP en Python (appelé Werkzeug), comprenant tout ce
              qu’il faut pour développer et déboguer son application web, mais
              aussi le nécessaire pour s’interfacer en production avec des
              serveurs HTTP plus performants ;
            </li>
            <li>
              un moteur de <em>templating</em> (appelé Jinja) permettant de
              générer des pages HTML en intégrant les données de manière
              dynamique côté serveur ;
            </li>
            <li>
              un système de gestions de routes, permettant d’associer
              facilement des URL (comprenant parfois des variables) à des
              fonctions Python.
            </li>
          </ul>
          <p>
            <strong>Contrairement à des <em>frameworks</em> plus complets,
            Flask se veut léger et peu intrusif.</strong> En particulier, il
            n’impose pas de gestionnaire de bases de données, de système de
            gestion de droits ou d’interface d’administration. Il laisse au
            contraire le soin à des modules tiers d’effectuer ces tâches,
            seulement si nécessaire.
          </p>
          <p>
            Après avoir
            <a href="https://flask.palletsprojects.com/en/3.0.x/installation/">installé Flask</a>,
            la meilleure manière d’apprendre à s’en servir est de suivre la section
            <a href="https://flask.palletsprojects.com/en/3.0.x/quickstart/">Quickstart</a>.
            La très grande majorité des informations nécessaires à cette
            formation sont disponibles dans cette page de documentation.
          </p>
          <p>
            Le <a href="https://flask.palletsprojects.com/en/3.0.x/tutorial/">tutoriel</a>
            propose une présentation très complète du <em>framework</em>,
            uniquement utile si vous souhaitez construire une application plus
            conséquente que celle que nous abordons dans cette formation.
          </p>
          <p>
            L’utilisation de Flask avec la base de données SQLite, comme c’est
            le cas dans l’application du module de programmation web, est
            décrite plus en détail dans
            <a href="https://flask.palletsprojects.com/en/3.0.x/patterns/sqlite3/">une page dédiée</a>.
          </p>
        </section>
      </section>

      <section id="atelier">
        <h2>Atelier</h2>
        <section class="introduction">
          <p>Temps estimé : 14h.</p>
          <p>
            Cet atelier vise à vous faire développer un jeu de taquin dans le
            terminal en Python. Vous ne connaissez pas ce jeu ? Vous allez vite
            comprendre son fonctionnement en lisant
            <a href="https://fr.wikipedia.org/wiki/Taquin">sa page Wikipédia</a> !
          </p>
          <p>
            Le développement sera à réaliser en 2 étapes distinctes, avec un
            rendu pour chacune de ces 2 versions.
          </p>
        </section>
        <section class="sujet">
          <h3>Premier rendu : fonctions</h3>
          <p>
            La première étape consiste à créer le jeu à l’aide de fonctions.
            Vous avez deux contraintes principales pour cette première étape :
          </p>
          <ul>
            <li>
              L’interface de votre jeu doit <strong>exactement</strong> être celle-ci :
              <pre>09 02 05 03
13 01 10   
14 08 06 04
12 11 07 15

Move: u

09 02 05   
13 01 10 03
14 08 06 04
12 11 07 15

Move: l

09 02    05
13 01 10 03
14 08 06 04
12 11 07 15</pre>

              À chaque tour, on affiche le plateau et on pose la question de la
              prochaine direction. L’utilisateur peut appuyer sur <kbd>u</kbd>
              pour déplacer la case vide vers le haut, <kbd>d</kbd> pour le
              bas, <kbd>l</kbd> pour la gauche et <kbd>r</kbd> pour la droite.
              On peut utiliser <kbd>q</kbd> pour quitter. Une autre valeur
              saisie ne change rien sur le plateau, tout comme un déplacement
              impossible.

              (Vous pouvez utiliser d’autres lettres que celles proposées pour
              les directions si vous le souhaitez.)

              <pre>06 03 05 04
09 02 11 08
10 01    12
13 07 14 15

Move: test

06 03 05 04
09 02 11 08
10 01    12
13 07 14 15

Move: z

06 03 05 04
09 02 11 08
10 01    12
13 07 14 15

Move: r

06 03 05 04
09 02 11 08
10 01 12   
13 07 14 15

Move: r

06 03 05 04
09 02 11 08
10 01 12   
13 07 14 15</pre>
            </li>
            <li>
              La structure de votre code doit être <strong>exactement</strong> celle-ci :

              <pre><code><span class="vert">from</span> random <span class="vert">import</span> choice


<span class="vert">def</span> create_board(rows, cols):
    <span class="gris">"""Create a board with original position of numbers.

    `rows` and `cols` are integers defining the number of rows and
    columns.

    Return `(board, blank)`.

    The returned `board` variable is a list of rows, and a row is
    a list of numbers. The numbers are integers, and the blank
    position is `None`.

    The returned `blank` variable is the `(x, y)` coordinates of
    the blank position, which is `(cols - 1, rows - 1)`.

    """</span>
    <span class="vert">pass</span>


<span class="vert">def</span> shuffle_board(board, blank):
    <span class="gris">"""Shuffle numbers of the board.

    `board` and `blank` are the returned values of `create_board`.

    Return the updated `blank` position.

    """</span>
    <span class="vert">pass</span>


<span class="vert">def</span> draw_board(board):
    <span class="gris">"""Draw the board."""</span>
    <span class="vert">pass</span>


<span class="vert">def</span> move(board, blank, position):
    <span class="gris">"""Swap the content of blank and position coordinates.

    This function doesn’t check that `blank` and `position` are
    next to each other.

    The board is modified in-place.

    Return the new `blank` position, which is `position`.

    """</span>
    <span class="vert">pass</span>


<span class="vert">def</span> is_solved(board):
    <span class="gris">"""Return `True` if the board is solved, else `False`."""</span>
    <span class="vert">pass</span>


<span class="gris"># Create, shuffle and draw board</span>
rows = 4
cols = 4
board, blank = create_board(rows, cols)
blank = shuffle_board(board, blank)
draw_board(board)

<span class="gris"># Play while the board is not solved</span>
<span class="vert">while</span> not is_solved(board):
    <span class="gris"># Ask for move direction</span>
    direction = input(<span class="rouge">"Move: "</span>)

    <span class="gris"># Quit game if direction is "q"</span>
    <span class="vert">pass</span>

    <span class="gris"># Depending on the asked direction, define the new position</span>
    <span class="vert">pass</span>

    <span class="gris"># Move number at found position</span>
    <span class="vert">if</span> position:
        blank = move(board, blank, position)

    <span class="gris"># Draw board</span>
    draw_board(board)
else:
    <span class="gris"># Board is solved, victory!</span>
    print(<span class="rouge">"!!! Victory !!!"</span>)</code></pre>

              Vous devez écrire du code à la place de la commande <code>pass</code> à
              chaque endroit où elle est utilisée. Vous devez bien sûr respecter la
              documentation et les commentaires.
            </li>
            <li>
              <strong>Vous devez utiliser uniquement des syntaxes et
              fonctionnalités abordées lors de cette formation.</strong> Si
              vous souhaitez tout de même aller au-delà, vous devez expliquer
              par un commentaire détaillé chaque fonctionnalité nouvelle que
              vous intégrez.
            </li>
          </ul>
          <p>
            Voici quelques informations qui vous aideront dans votre projet :
          </p>
          <ul>
            <li>
              Il est possible d’écrire chacune des fonctions avec moins de 15
              lignes. Si l’une de vos fonctions devient trop grandes, votre
              algorithme n’est peut-être pas optimal.
            </li>
            <li>
              Le plateau est une liste de lignes, et une ligne est une liste de
              nombres. Par exemple, pour un plateau de 3 cases par 3 cases,
              votre plateau original est donc
              <pre><code>board = [ [1, 2, 3], [4, 5, 6], [7, 8, <span class="vert">None</span>] ]</code></pre>
              autrement écrit
              <pre><code>board = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, <span class="vert">None</span>],
]</code></pre>
              On accède à un nombre positionné en <code>(x, y)</code> avec
              <code>board[y][x]</code>. Par exemple, sur notre plateau précédent,
              <code>board[1][2] == 6</code>.
            </li>
            <li>
              La taille du plateau par défaut est de 4 × 4, mais vous pouvez
              utiliser une taille de 2 × 2 ou 3 × 3 lors de votre développement !
            </li>
            <li>
              L’affichage des nombres est fait sur 2 chiffres, avec un 0 devant
              si besoin. Il est possible de faire cela avec les f-strings de
              Python:
              <pre><code>number = 2
print(<span class="rouge">f'<span class="bleu">{number}</span>'</span>)  <span class="gris"># 2</span>
print(<span class="rouge">f'<span class="bleu">{number:02n}</span>'</span>)  <span class="gris"># 02</span></code></pre>
            </li>
            <li>
              Par défaut, la fonction <code>print</code> saute une ligne après
              l’affichage. Vous pouvez éviter cela grâce au paramètre
              <code>end</code> de cette fonction, comme ceci :
              <pre><code><span class="gris"># Print 1234 56</span>
print(12, end=<span class="rouge">''</span>)
print(34, end=<span class="rouge">' '</span>)
print(56)</code></pre>
            </li>
            <li>
              Mélanger les nombres du plateau ne consiste pas à mettre les
              nombres dans un ordre aléatoire : certaines combinaisons sont en
              effet impossibles à résoudre ! La solution la plus simple est
              sans doute de faire comme avec un vrai jeu, c’est-à-dire de faire
              beaucoup de permutations au hasard.
            </li>
          </ul>
          <h4>Correction</h4>
          <p>
            Les solutions ne doivent pas contenir de fonctionnalités qui n’ont
            pas été abordées sans commentaire associé, en particulier :
          </p>
          <ul>
            <li>les <em>list comprehensions</em>,</li>
            <li><code>match</code>,</li>
            <li><code>*args</code> et <code>**kwargs</code>,</li>
            <li><code>enumerate</code>,</li>
            <li><code>join</code>,</li>
            <li><code>in</code> dans un test.</li>
          </ul>
          <pre style="font-size: 0.6em">from random import choice


def create_board(rows, cols):
    """Create a board with original position of numbers.

    `rows` and `cols` are integers defining the numbers of rows
    and columns.

    Return `(board, blank)`.

    The returned `board` variable is a list of rows, and a row
    is a list of numbers. The numbers are integers, and the blank
    position is `None`.

    The returned `blank` variable is the `(x, y)` coordinates of
    the blank position, which is `(cols - 1, rows - 1)`.

    """
    board = []
    for y in range(rows):
        row = []
        for x in range(cols):
            row.append(1 + x + y * cols)
        board.append(row)
    board[-1][-1] = None
    blank = (cols - 1, rows - 1)
    return board, blank


def shuffle_board(board, blank):
    """Shuffle numbers of the board.

    `board` and `blank` are the returned values of `create_board`.

    Return the updated `blank` position.

    """
    cols, rows = len(board[0]), len(board)
    for _ in range(100):
        moves = []
        if blank[0] > 0:
            moves.append((blank[0] - 1, blank[1]))
        if blank[0] < cols - 1:
            moves.append((blank[0] + 1, blank[1]))
        if blank[1] > 0:
            moves.append((blank[0], blank[1] - 1))
        if blank[1] < rows - 1:
            moves.append((blank[0], blank[1] + 1))
        blank = move(board, blank, choice(moves))
    return blank


def draw_board(board):
    """Draw the board."""
    print()
    for row in board:
        for number in row:
            if number:
                print(f'{number:02n}', end=' ')
            else:
                print('  ', end=' ')
        print()
    print()


def move(board, blank, position):
    """Swap the content of blank and position coordinates.

    This function doesn’t check that `blank` and `position` are
    next to each other.

    The board is modified in-place.

    Return the new `blank` position, which is `position`.

    """
    board[blank[0]][blank[1]] = board[position[0]][position[1]]
    board[position[0]][position[1]] = None
    return position


def is_solved(board):
    """Return `True` if the board is solved, else `False`."""
    numbers = []
    for row in board:
        for number in row:
            numbers.append(number)
    solution = []
    for number in range(1, len(numbers)):
        solution.append(number)
    solution.append(None)
    return numbers == solution


# Create, shuffle and draw board
rows = 4
cols = 4
board, blank = create_board(rows, cols)
blank = shuffle_board(board, blank)
draw_board(board)

# Play while the board is not solved
while not is_solved(board):
    # Ask for move direction
    direction = input("Move: ")

    # Quit game if direction is "q"
    if direction == "q":
        break

    # Depending on the asked direction, define the new position
    position = None
    if direction == "u" and blank[0] > 0:
        position = (blank[0] - 1, blank[1])
    elif direction == "d" and blank[0] < rows - 1:
        position = (blank[0] + 1, blank[1])
    elif direction == "l" and blank[1] > 0:
        position = (blank[0], blank[1] - 1)
    elif direction == "r" and blank[1] < cols - 1:
        position = (blank[0], blank[1] + 1)

    # Move number at found position
    if position:
        blank = move(board, blank, position)

    # Draw board
    draw_board(board)
else:
    # Board is solved, victory!
    print("!!! Victory !!!")</pre>
          <h3>Deuxième rendu : classes</h3>
          <p>
            Lors de cette étape, vous décidez de remplacer les fonctions de
            votre premier rendu par une classe <code>Board</code> comprenant les
            méthodes <code>__init__</code> (à la place de <code>create_board</code>),
            <code>shuffle</code>, <code>draw</code>, <code>move</code> et
            <code>is_solved</code>.
          </p>
          <p>
            L’interface doit rester la même !
          </p>
          <p>
            Voici quelques informations qui vous aideront dans votre projet, et
            quelques idées d’améliorations facultatives à intégrer :
          </p>
          <ul>
            <li>
              Votre classe intègre évidemment les données qui étaient dans
              <code>board</code>, mais elle peut également comporter un
              attribut <code>blank</code>. Une autre possibilité est de ne plus
              avoir à garder l’information de <code>blank</code> et à la
              recalculer au besoin, uniquement dans <code>move</code> !
            </li>
            <li>
              Vous pouvez trouver une solution pour afficher les nombres selon
              le nombre maximal à afficher. Par exemple, pour une grille 3 × 3
              (le maximum est 8), on peut afficher les nombres sur un chiffre,
              et pour une grille 11 × 11 (le maximum est 120), on peut les
              afficher sur 3 chiffres.
            </li>
            <li>
              Vous pouvez utiliser Rich pour mettre des couleurs dans votre
              interface !
            </li>
          </ul>
          <h4>Correction</h4>
          <pre style="font-size: 0.6em">from random import choice


class Board:
    def __init__(self, rows, cols):
        self.rows = rows
        self.cols = cols
        self.cell_size = len(str(rows * cols))
        self.numbers = []
        for y in range(rows):
            row = []
            for x in range(cols):
                row.append(1 + x + y * cols)
            self.numbers.append(row)
        self.numbers[-1][-1] = None
        self.shuffle()


    def shuffle(self):
        moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        for _ in range((self.rows * self.cols) ** 2):
            x, y = choice(moves)
            self.move(x, y)


    def draw(self):
        print()
        for row in self.numbers:
            for number in row:
                if number:
                    print(f'{number:0{self.cell_size}n}', end=' ')
                else:
                    print(' ' * self.cell_size, end=' ')
            print()
        print()


    def move(self, x, y):
        blank_y = 0
        for row in self.numbers:
            if None in row:
                blank_x = row.index(None)
                break
            blank_y = blank_y + 1
        pos_x, pos_y = blank_x + x, blank_y + y
        if 0 <= pos_x < self.cols and 0 <= pos_y < self.rows:
            self.numbers[blank_y][blank_x] = (
                self.numbers[pos_y][pos_x])
            self.numbers[pos_y][pos_x] = None


    def is_solved(self):
        numbers = []
        for row in self.numbers:
            for number in row:
                numbers.append(number)
        solution = list(range(1, len(numbers))) + [None]
        return numbers == solution


rows = cols = 4
board = Board(rows, cols)
board.draw()

while not board.is_solved():
    direction = input("Direction : ")
    if direction == "q":
        break
    elif direction == "l":
        board.move(-1, 0)
    elif direction == "r":
        board.move(1, 0)
    elif direction == "u":
        board.move(0, -1)
    elif direction == "d":
        board.move(0, 1)
    board.draw()
else:
    print("!!! Victory !!!")</pre>
        </section>
      </section>
    </main>
  </body>
</html>
